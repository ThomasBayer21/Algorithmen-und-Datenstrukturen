<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AVL-Baum Visualisierung</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #e4dcf0 0%, #d4cce0 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        @media (max-width: 768px) {
            .container { padding: 20px; }
            body { padding: 10px; }
        }
        .header { text-align: center; margin-bottom: 30px; }
        h1 { color: #333; margin-bottom: 10px; }
        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: #2c3e50;
            text-decoration: none;
            font-weight: bold;
        }
        .back-link:hover { text-decoration: underline; }
        .description {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            line-height: 1.6;
        }
        .info-box {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #2196f3;
            margin: 20px 0;
            font-size: 14px;
            line-height: 1.4;
        }
        .info-box h3 { color: #333; margin-bottom: 8px; font-size: 16px; }
        .info-box p { margin: 4px 0; }
        .info-box ul { margin: 4px 0 8px 20px; }
        .info-box li { margin: 2px 0; }
        .visualization-container {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        .canvas-wrapper {
            position: relative;
            overflow: hidden;
            margin: 20px 0;
            background:
                linear-gradient(0deg, transparent 24%, rgba(102, 126, 234, 0.03) 25%, rgba(102, 126, 234, 0.03) 26%, transparent 27%, transparent 74%, rgba(102, 126, 234, 0.03) 75%, rgba(102, 126, 234, 0.03) 76%, transparent 77%, transparent),
                linear-gradient(90deg, transparent 24%, rgba(102, 126, 234, 0.03) 25%, rgba(102, 126, 234, 0.03) 26%, transparent 27%, transparent 74%, rgba(102, 126, 234, 0.03) 75%, rgba(102, 126, 234, 0.03) 76%, transparent 77%, transparent);
            background-size: 50px 50px;
            background-color: #fafafa;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            height: 600px;
        }
        .tree-canvas {
            display: block;
            margin: 0 auto;
            cursor: grab;
        }
        .tree-canvas:active {
            cursor: grabbing;
        }
        .zoom-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 10;
        }
        .zoom-btn {
            width: 45px;
            height: 45px;
            border: none;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            cursor: pointer;
            font-size: 22px;
            font-weight: bold;
            color: #2c3e50;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .zoom-btn:hover {
            background: #667eea;
            color: white;
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.3);
        }
        .zoom-btn:active {
            transform: scale(0.95);
        }
        .zoom-info {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            color: white;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            z-index: 10;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            letter-spacing: 0.5px;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
            align-items: center;
        }
        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            .controls > * { width: 100%; }
        }
        input[type="number"] {
            padding: 12px 16px;
            font-size: 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            width: 140px;
            transition: border-color 0.2s;
        }
        input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
        }
        @media (max-width: 768px) {
            input[type="number"] { width: 100%; }
        }
        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            background: #667eea;
            color: white;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        button:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        button:active {
            transform: translateY(0);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        button.secondary {
            background: #6c757d;
            box-shadow: 0 2px 8px rgba(108, 117, 125, 0.3);
        }
        button.secondary:hover {
            background: #5a6268;
            box-shadow: 0 4px 12px rgba(108, 117, 125, 0.4);
        }
        button.danger {
            background: #dc3545;
            box-shadow: 0 2px 8px rgba(220, 53, 69, 0.3);
        }
        button.danger:hover {
            background: #c82333;
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.4);
        }
        .speed-control {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 15px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 8px;
            flex-wrap: wrap;
            border: 1px solid #dee2e6;
        }
        @media (max-width: 768px) {
            .speed-control {
                flex-direction: column;
                align-items: stretch;
            }
        }
        .speed-btn {
            padding: 10px 18px;
            font-size: 14px;
            background: white;
            color: #2c3e50;
            border: 2px solid #e0e0e0;
            transition: all 0.2s;
        }
        .speed-btn:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }
        .speed-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        .explanation-box {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            padding: 20px;
            border-radius: 10px;
            border-left: 5px solid #ffc107;
            margin: 20px 0;
            min-height: 100px;
            line-height: 1.6;
            box-shadow: 0 2px 8px rgba(255, 193, 7, 0.2);
        }
        .explanation-box h4 {
            color: #856404;
            margin-bottom: 10px;
            font-size: 18px;
        }
        .explanation-box p {
            color: #856404;
            margin: 5px 0;
        }
        .step-controls {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        @media (max-width: 768px) {
            .step-controls {
                flex-direction: column;
            }
        }
        .complexity-badge {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
            margin-left: 10px;
        }
        .badge-good { background: #28a745; color: white; }
        .code-block {
            background: #282c34;
            color: #abb2bf;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            margin: 15px 0;
            overflow-x: auto;
            line-height: 1.8;
            white-space: pre-wrap;
        }
        .code-comment { color: #5c6370; }
        .code-keyword { color: #c678dd; }
        .code-function { color: #61afef; }
        .section { margin: 40px 0; }
        .section h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group h3 {
            font-size: 16px;
            color: #666;
            margin-bottom: 10px;
            font-weight: 600;
        }
        .operations-log {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            max-height: 300px;
            overflow-y: auto;
        }
        .operations-log h4 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 16px;
        }
        .operation-item {
            padding: 8px 12px;
            margin: 5px 0;
            background: white;
            border-left: 4px solid #667eea;
            border-radius: 4px;
            font-size: 14px;
            line-height: 1.5;
        }
        .operation-item.rotation {
            border-left-color: #ffc107;
        }
        .operation-item.found {
            border-left-color: #28a745;
        }
        .operation-item.error {
            border-left-color: #dc3545;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Zurück zur Übersicht</a>
        <div class="header">
            <h1>AVL-Baum Visualisierung</h1>
        </div>
        <div class="description">
            <strong>Überblick:</strong> Ein AVL-Baum ist ein selbstbalancierender binärer Suchbaum,
            benannt nach den Erfindern Adelson-Velsky und Landis. Der Baum garantiert, dass die Höhendifferenz
            zwischen linkem und rechtem Teilbaum (Balance-Faktor) bei jedem Knoten maximal 1 beträgt.
            Dadurch bleiben Such-, Einfüge- und Löschoperationen in <strong>O(log n)</strong> Zeit.
        </div>

        <div class="section">
            <h2>1. Interaktive AVL-Baum Visualisierung</h2>
            <div class="info-box">
                <h3>Eigenschaften</h3>
                <p><strong>Balance-Faktor:</strong> |höhe(links) - höhe(rechts)| ≤ 1 für jeden Knoten</p>
                <p><strong>Zeitkomplexität:</strong> <span class="complexity-badge badge-good">O(log n)</span> garantiert • <strong>Navigation:</strong> Mausrad zum Zoomen, Ziehen zum Verschieben</p>

                <p style="margin-top: 8px;"><strong>Darstellung unter jedem Knoten:</strong></p>
                <ul>
                    <li><strong>h</strong> = Höhe • <strong>b</strong> = Balance-Faktor (h(links) - h(rechts))</li>
                    <li>b = 0: perfekt balanciert | b = ±1: ok | |b| > 1: unbalanciert → Rotation</li>
                </ul>

                <p style="margin-top: 8px;"><strong>Knotenfarben:</strong></p>
                <ul>
                    <li><span style="color: #667eea;">⬤ Blau</span> = Normaler Knoten • <span style="color: #17a2b8;">⬤ Cyan</span> = Neu eingefügt • <span style="color: #28a745;">⬤ Grün</span> = Besucht/Hervorgehoben</li>
                    <li><span style="color: #ffc107;">⬤ Gelb</span> = Rotation läuft • <span style="color: #dc3545;">⬤ Rot</span> = Unbalanciert (benötigt Rotation)</li>
                </ul>
            </div>

            <div class="visualization-container">
                <div class="control-group">
                    <h3>Operationen</h3>
                    <div class="controls">
                        <input type="number" id="treeValue" placeholder="Wert (1-99)" value="50" min="1" max="99">
                        <button onclick="insertNode()">Einfügen</button>
                        <button onclick="deleteNode()" class="danger">Löschen</button>
                        <button onclick="searchNode()" class="secondary">Suchen</button>
                        <button onclick="clearTree()" class="secondary">Leerer Baum</button>
                        <button onclick="resetTree()" class="secondary">Reset</button>
                        <button onclick="randomTree()" class="secondary">Zufällig</button>
                    </div>
                </div>

                <div class="control-group">
                    <h3>Animationsgeschwindigkeit</h3>
                    <div class="speed-control">
                        <button class="speed-btn" onclick="setSpeed(2000)">Sehr Langsam</button>
                        <button class="speed-btn" onclick="setSpeed(1000)">Langsam</button>
                        <button class="speed-btn active" onclick="setSpeed(500)">Normal</button>
                        <button class="speed-btn" onclick="setSpeed(200)">Schnell</button>
                    </div>
                </div>

                <div class="control-group">
                    <h3>Schritt-für-Schritt</h3>
                    <div class="step-controls">
                        <button onclick="toggleStepMode()" id="stepModeBtn" class="secondary">Schritt-Modus: AUS</button>
                        <button onclick="nextStep()" id="nextStepBtn" disabled>Nächster Schritt</button>
                    </div>
                </div>

                <div class="explanation-box" id="explanationBox">
                    <h4>Bereit</h4>
                    <p>Füge Werte ein, um die AVL-Baum-Operationen zu sehen.</p>
                    <p><strong>Tipp:</strong> Nutze Mausrad zum Zoomen und ziehe mit der Maus zum Verschieben.</p>
                </div>

                <div class="canvas-wrapper">
                    <div class="zoom-controls">
                        <button class="zoom-btn" onclick="zoomIn()" title="Vergrößern">+</button>
                        <button class="zoom-btn" onclick="zoomOut()" title="Verkleinern">−</button>
                        <button class="zoom-btn" onclick="resetZoom()" title="Zoom zurücksetzen">⊙</button>
                    </div>
                    <div class="zoom-info" id="zoomInfo">Zoom: 100%</div>
                    <canvas id="treeCanvas" class="tree-canvas"></canvas>
                </div>

                <div class="operations-log">
                    <h4>Operations-Historie (Aktueller Befehl)</h4>
                    <div id="operationsLog">
                        <p style="color: #999; font-style: italic;">Noch keine Operationen ausgeführt.</p>
                    </div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>2. AVL-Rotationen</h2>
            <div class="info-box">
                <h3>Vier Rotations-Arten:</h3>
                <ul style="margin-left: 20px; line-height: 2;">
                    <li><strong>Links-Rotation (RR):</strong> Rechtes Kind wird zur neuen Wurzel</li>
                    <li><strong>Rechts-Rotation (LL):</strong> Linkes Kind wird zur neuen Wurzel</li>
                    <li><strong>Links-Rechts-Rotation (LR):</strong> Erst links, dann rechts rotieren</li>
                    <li><strong>Rechts-Links-Rotation (RL):</strong> Erst rechts, dann links rotieren</li>
                </ul>
            </div>

            <div class="code-block">
<span class="code-comment">// AVL Node mit Höhe und Balance-Faktor</span>
<span class="code-keyword">class</span> <span class="code-function">AVLNode</span> {
    <span class="code-function">constructor</span>(value) {
        <span class="code-keyword">this</span>.value = value;
        <span class="code-keyword">this</span>.left = <span class="code-keyword">null</span>;
        <span class="code-keyword">this</span>.right = <span class="code-keyword">null</span>;
        <span class="code-keyword">this</span>.height = <span class="code-number">1</span>;
    }
}

<span class="code-comment">// Rechts-Rotation (LL)</span>
<span class="code-keyword">function</span> <span class="code-function">rotateRight</span>(y) {
    <span class="code-keyword">const</span> x = y.left;
    <span class="code-keyword">const</span> T2 = x.right;

    x.right = y;
    y.left = T2;

    y.height = <span class="code-function">Math.max</span>(<span class="code-function">height</span>(y.left), <span class="code-function">height</span>(y.right)) + <span class="code-number">1</span>;
    x.height = <span class="code-function">Math.max</span>(<span class="code-function">height</span>(x.left), <span class="code-function">height</span>(x.right)) + <span class="code-number">1</span>;

    <span class="code-keyword">return</span> x;
}

<span class="code-comment">// Links-Rotation (RR)</span>
<span class="code-keyword">function</span> <span class="code-function">rotateLeft</span>(x) {
    <span class="code-keyword">const</span> y = x.right;
    <span class="code-keyword">const</span> T2 = y.left;

    y.left = x;
    x.right = T2;

    x.height = <span class="code-function">Math.max</span>(<span class="code-function">height</span>(x.left), <span class="code-function">height</span>(x.right)) + <span class="code-number">1</span>;
    y.height = <span class="code-function">Math.max</span>(<span class="code-function">height</span>(y.left), <span class="code-function">height</span>(y.right)) + <span class="code-number">1</span>;

    <span class="code-keyword">return</span> y;
}
            </div>
        </div>
    </div>

    <script>
        class AVLNode {
            constructor(value) {
                this.value = value;
                this.left = null;
                this.right = null;
                this.height = 1;
                this.x = 0;
                this.y = 0;
                this.targetX = 0;
                this.targetY = 0;
                this.isNew = false;
                this.isHighlighted = false;
                this.isRotating = false;
            }
        }

        let root = null;
        let animationSpeed = 500;
        let isAnimating = false;
        let stepMode = false;
        let operationsLog = [];

        // Zoom and Pan
        let scale = 1.0;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let lastOffsetX = 0;
        let lastOffsetY = 0;

        const canvas = document.getElementById('treeCanvas');
        const ctx = canvas.getContext('2d');

        // Initialize canvas size
        function initCanvas() {
            const wrapper = canvas.parentElement;
            canvas.width = wrapper.clientWidth;
            canvas.height = wrapper.clientHeight;
        }

        // Center the tree
        function centerTree() {
            if (root === null) return;

            // Calculate tree bounds
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;

            function getBounds(node) {
                if (node === null) return;
                minX = Math.min(minX, node.targetX);
                maxX = Math.max(maxX, node.targetX);
                minY = Math.min(minY, node.targetY);
                maxY = Math.max(maxY, node.targetY);
                if (node.left) getBounds(node.left);
                if (node.right) getBounds(node.right);
            }

            calculatePositions(root, 0, canvas.width, 0);
            getBounds(root);

            // Calculate center offset
            const treeWidth = maxX - minX;
            const treeHeight = maxY - minY;
            const treeCenterX = (minX + maxX) / 2;
            const treeCenterY = (minY + maxY) / 2;

            // Canvas center
            const canvasCenterX = canvas.width / 2;
            const canvasCenterY = canvas.height / 2;

            // Calculate optimal scale to fit the tree with padding
            const paddingFactor = 0.85;
            const scaleX = (canvas.width * paddingFactor) / (treeWidth + 100);
            const scaleY = (canvas.height * paddingFactor) / (treeHeight + 100);
            scale = Math.min(scaleX, scaleY, 1.2);
            scale = Math.max(0.3, Math.min(scale, 3));

            // Center offset
            offsetX = canvasCenterX - treeCenterX * scale;
            offsetY = canvasCenterY - treeCenterY * scale;

            updateZoomInfo();
        }

        // Zoom functions
        function zoomIn() {
            scale = Math.min(scale * 1.2, 3);
            updateZoomInfo();
            drawTree();
        }

        function zoomOut() {
            scale = Math.max(scale / 1.2, 0.3);
            updateZoomInfo();
            drawTree();
        }

        function resetZoom() {
            centerTree();
            drawTree();
        }

        function updateZoomInfo() {
            document.getElementById('zoomInfo').textContent = `Zoom: ${Math.round(scale * 100)}%`;
        }

        // Mouse wheel zoom
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = scale * delta;

            if (newScale >= 0.3 && newScale <= 3) {
                // Zoom towards mouse position
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const worldX = (mouseX - offsetX) / scale;
                const worldY = (mouseY - offsetY) / scale;

                scale = newScale;

                offsetX = mouseX - worldX * scale;
                offsetY = mouseY - worldY * scale;

                updateZoomInfo();
                drawTree();
            }
        });

        // Mouse drag for panning
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            lastOffsetX = offsetX;
            lastOffsetY = offsetY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                offsetX = lastOffsetX + (e.clientX - dragStartX);
                offsetY = lastOffsetY + (e.clientY - dragStartY);
                drawTree();
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        // Touch support for mobile
        let touchStartDist = 0;
        let touchStartScale = 1;

        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                touchStartDist = Math.sqrt(dx * dx + dy * dy);
                touchStartScale = scale;
            } else if (e.touches.length === 1) {
                isDragging = true;
                dragStartX = e.touches[0].clientX;
                dragStartY = e.touches[0].clientY;
                lastOffsetX = offsetX;
                lastOffsetY = offsetY;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const newScale = touchStartScale * (dist / touchStartDist);

                if (newScale >= 0.3 && newScale <= 3) {
                    scale = newScale;
                    updateZoomInfo();
                    drawTree();
                }
            } else if (e.touches.length === 1 && isDragging) {
                offsetX = lastOffsetX + (e.touches[0].clientX - dragStartX);
                offsetY = lastOffsetY + (e.touches[0].clientY - dragStartY);
                drawTree();
            }
        });

        canvas.addEventListener('touchend', () => {
            isDragging = false;
        });

        // Window resize handler
        window.addEventListener('resize', () => {
            initCanvas();
            centerTree();
            drawTree();
        });

        function height(node) {
            return node === null ? 0 : node.height;
        }

        function updateHeight(node) {
            if (node !== null) {
                node.height = Math.max(height(node.left), height(node.right)) + 1;
            }
        }

        function getBalance(node) {
            return node === null ? 0 : height(node.left) - height(node.right);
        }

        function rotateRight(y) {
            const x = y.left;
            const T2 = x.right;

            x.right = y;
            y.left = T2;

            updateHeight(y);
            updateHeight(x);

            return x;
        }

        function rotateLeft(x) {
            const y = x.right;
            const T2 = y.left;

            y.left = x;
            x.right = T2;

            updateHeight(x);
            updateHeight(y);

            return y;
        }

        async function insert(node, value, path = []) {
            if (node === null) {
                await explain('Neuer Knoten erstellt', `Wert ${value} wird als neuer Knoten eingefügt.`);
                const newNode = new AVLNode(value);
                newNode.isNew = true;
                await animateTree();
                newNode.isNew = false;
                return newNode;
            }

            node.isHighlighted = true;
            await animateTree();
            node.isHighlighted = false;

            if (value < node.value) {
                await explain('Navigation nach links', `${value} < ${node.value}, gehe zum linken Kind.`);
                node.left = await insert(node.left, value, [...path, 'left']);
            } else if (value > node.value) {
                await explain('Navigation nach rechts', `${value} > ${node.value}, gehe zum rechten Kind.`);
                node.right = await insert(node.right, value, [...path, 'right']);
            } else {
                await explain('Duplikat gefunden', `Wert ${value} existiert bereits. Keine Änderung.`);
                return node;
            }

            updateHeight(node);
            const balance = getBalance(node);

            await explain('Balance prüfen', `Balance-Faktor von Knoten ${node.value}: ${balance}`);
            await animateTree();

            // Links-Links Fall
            if (balance > 1 && value < node.left.value) {
                await explain('Links-Links Fall (LL)', `Balance: ${balance}. Führe Rechts-Rotation durch.`);
                node.isRotating = true;
                if (node.left) node.left.isRotating = true;
                await animateTree();
                const result = rotateRight(node);
                result.isRotating = false;
                if (result.right) result.right.isRotating = false;
                await animateTree();
                return result;
            }

            // Rechts-Rechts Fall
            if (balance < -1 && value > node.right.value) {
                await explain('Rechts-Rechts Fall (RR)', `Balance: ${balance}. Führe Links-Rotation durch.`);
                node.isRotating = true;
                if (node.right) node.right.isRotating = true;
                await animateTree();
                const result = rotateLeft(node);
                result.isRotating = false;
                if (result.left) result.left.isRotating = false;
                await animateTree();
                return result;
            }

            // Links-Rechts Fall
            if (balance > 1 && value > node.left.value) {
                await explain('Links-Rechts Fall (LR)', `Balance: ${balance}. Schritt 1: Links-Rotation.`);
                if (node.left) node.left.isRotating = true;
                await animateTree();
                node.left = rotateLeft(node.left);
                if (node.left) node.left.isRotating = false;
                await animateTree();

                await explain('Links-Rechts Fall (LR)', `Schritt 2: Rechts-Rotation.`);
                node.isRotating = true;
                await animateTree();
                const result = rotateRight(node);
                result.isRotating = false;
                await animateTree();
                return result;
            }

            // Rechts-Links Fall
            if (balance < -1 && value < node.right.value) {
                await explain('Rechts-Links Fall (RL)', `Balance: ${balance}. Schritt 1: Rechts-Rotation.`);
                if (node.right) node.right.isRotating = true;
                await animateTree();
                node.right = rotateRight(node.right);
                if (node.right) node.right.isRotating = false;
                await animateTree();

                await explain('Rechts-Links Fall (RL)', `Schritt 2: Links-Rotation.`);
                node.isRotating = true;
                await animateTree();
                const result = rotateLeft(node);
                result.isRotating = false;
                await animateTree();
                return result;
            }

            return node;
        }

        function findMin(node) {
            while (node.left !== null) {
                node = node.left;
            }
            return node;
        }

        async function deleteNodeHelper(node, value) {
            if (node === null) {
                await explain('Knoten nicht gefunden', `Wert ${value} existiert nicht im Baum.`);
                return null;
            }

            node.isHighlighted = true;
            await animateTree();
            node.isHighlighted = false;

            if (value < node.value) {
                await explain('Suche links', `${value} < ${node.value}, suche im linken Teilbaum.`);
                node.left = await deleteNodeHelper(node.left, value);
            } else if (value > node.value) {
                await explain('Suche rechts', `${value} > ${node.value}, suche im rechten Teilbaum.`);
                node.right = await deleteNodeHelper(node.right, value);
            } else {
                await explain('Knoten gefunden', `Knoten ${value} wird gelöscht.`);

                if (node.left === null || node.right === null) {
                    node = node.left !== null ? node.left : node.right;
                    await explain('Einfacher Fall', 'Knoten hat maximal ein Kind.');
                    await animateTree();
                } else {
                    const minNode = findMin(node.right);
                    await explain('Zwei Kinder', `Ersetze mit Inorder-Nachfolger: ${minNode.value}`);
                    node.value = minNode.value;
                    node.right = await deleteNodeHelper(node.right, minNode.value);
                }
            }

            if (node === null) return null;

            updateHeight(node);
            const balance = getBalance(node);

            await explain('Rebalancierung prüfen', `Balance von Knoten ${node.value}: ${balance}`);
            await animateTree();

            // Links-Links
            if (balance > 1 && getBalance(node.left) >= 0) {
                await explain('Links-Links (LL)', 'Führe Rechts-Rotation durch.');
                node.isRotating = true;
                await animateTree();
                const result = rotateRight(node);
                result.isRotating = false;
                await animateTree();
                return result;
            }

            // Links-Rechts
            if (balance > 1 && getBalance(node.left) < 0) {
                await explain('Links-Rechts (LR)', 'Schritt 1: Links-Rotation.');
                node.left = rotateLeft(node.left);
                await animateTree();
                await explain('Links-Rechts (LR)', 'Schritt 2: Rechts-Rotation.');
                node.isRotating = true;
                await animateTree();
                const result = rotateRight(node);
                result.isRotating = false;
                await animateTree();
                return result;
            }

            // Rechts-Rechts
            if (balance < -1 && getBalance(node.right) <= 0) {
                await explain('Rechts-Rechts (RR)', 'Führe Links-Rotation durch.');
                node.isRotating = true;
                await animateTree();
                const result = rotateLeft(node);
                result.isRotating = false;
                await animateTree();
                return result;
            }

            // Rechts-Links
            if (balance < -1 && getBalance(node.right) > 0) {
                await explain('Rechts-Links (RL)', 'Schritt 1: Rechts-Rotation.');
                node.right = rotateRight(node.right);
                await animateTree();
                await explain('Rechts-Links (RL)', 'Schritt 2: Links-Rotation.');
                node.isRotating = true;
                await animateTree();
                const result = rotateLeft(node);
                result.isRotating = false;
                await animateTree();
                return result;
            }

            return node;
        }

        function addToOperationsLog(title, message, type = 'normal') {
            operationsLog.push({ title, message, type });
            updateOperationsLogDisplay();
        }

        function clearOperationsLog() {
            operationsLog = [];
            updateOperationsLogDisplay();
        }

        function updateOperationsLogDisplay() {
            const logContainer = document.getElementById('operationsLog');
            if (operationsLog.length === 0) {
                logContainer.innerHTML = '<p style="color: #999; font-style: italic;">Noch keine Operationen ausgeführt.</p>';
                return;
            }

            let html = '';
            operationsLog.forEach((op, index) => {
                const className = op.type === 'rotation' ? 'operation-item rotation' :
                                 op.type === 'found' ? 'operation-item found' :
                                 op.type === 'error' ? 'operation-item error' :
                                 'operation-item';
                html += `<div class="${className}"><strong>${index + 1}. ${op.title}:</strong> ${op.message}</div>`;
            });
            logContainer.innerHTML = html;

            // Auto-scroll to bottom
            logContainer.parentElement.scrollTop = logContainer.parentElement.scrollHeight;
        }

        async function explain(title, message) {
            const box = document.getElementById('explanationBox');
            box.innerHTML = `<h4>${title}</h4><p>${message}</p>`;

            // Determine operation type for color coding
            let type = 'normal';
            if (title.toLowerCase().includes('rotation')) {
                type = 'rotation';
            } else if (title.toLowerCase().includes('gefunden') || title.toLowerCase() === 'gefunden!') {
                type = 'found';
            } else if (title.toLowerCase().includes('nicht gefunden') || title.toLowerCase().includes('duplikat')) {
                type = 'error';
            }

            addToOperationsLog(title, message, type);

            if (stepMode) {
                await waitForNextStep();
            } else {
                await sleep(animationSpeed);
            }
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function waitForNextStep() {
            return new Promise(resolve => {
                window.resolveStep = resolve;
            });
        }

        function nextStep() {
            if (window.resolveStep) {
                window.resolveStep();
                window.resolveStep = null;
            }
        }

        function toggleStepMode() {
            stepMode = !stepMode;
            const btn = document.getElementById('stepModeBtn');
            const nextBtn = document.getElementById('nextStepBtn');
            btn.textContent = `Schritt-Modus: ${stepMode ? 'EIN' : 'AUS'}`;
            nextBtn.disabled = !stepMode;
        }

        function setSpeed(speed) {
            animationSpeed = speed;
            document.querySelectorAll('.speed-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        }

        async function insertNode() {
            if (isAnimating) return;
            const value = parseInt(document.getElementById('treeValue').value);
            if (isNaN(value) || value < 1 || value > 99) {
                alert('Bitte gebe einen Wert zwischen 1 und 99 ein.');
                return;
            }

            isAnimating = true;
            clearOperationsLog();
            await explain('Start', `Füge Wert ${value} in den AVL-Baum ein.`);
            root = await insert(root, value);
            await animateTree();
            await explain('Abgeschlossen', `Wert ${value} erfolgreich eingefügt. Baum bleibt balanciert.`);
            isAnimating = false;
        }

        async function deleteNode() {
            if (isAnimating) return;
            const value = parseInt(document.getElementById('treeValue').value);
            if (isNaN(value)) {
                alert('Bitte gebe einen gültigen Wert ein.');
                return;
            }

            isAnimating = true;
            clearOperationsLog();
            await explain('Start', `Lösche Wert ${value} aus dem AVL-Baum.`);
            root = await deleteNodeHelper(root, value);
            await animateTree();
            await explain('Abgeschlossen', 'Löschvorgang abgeschlossen. Baum bleibt balanciert.');
            isAnimating = false;
        }

        async function searchNode() {
            if (isAnimating) return;
            const value = parseInt(document.getElementById('treeValue').value);
            if (isNaN(value)) {
                alert('Bitte gebe einen gültigen Wert ein.');
                return;
            }

            isAnimating = true;
            clearOperationsLog();
            let current = root;
            let found = false;

            await explain('Start', `Suche Wert ${value} im AVL-Baum.`);

            while (current !== null) {
                current.isHighlighted = true;
                await animateTree();

                if (value === current.value) {
                    await explain('Gefunden!', `Wert ${value} wurde gefunden.`);
                    found = true;
                    current.isHighlighted = false;
                    break;
                } else if (value < current.value) {
                    await explain('Nach links', `${value} < ${current.value}, gehe nach links.`);
                    current.isHighlighted = false;
                    current = current.left;
                } else {
                    await explain('Nach rechts', `${value} > ${current.value}, gehe nach rechts.`);
                    current.isHighlighted = false;
                    current = current.right;
                }
            }

            if (!found) {
                await explain('Nicht gefunden', `Wert ${value} existiert nicht im Baum.`);
            }

            await animateTree();
            isAnimating = false;
        }

        function clearTree() {
            root = null;
            clearOperationsLog();
            drawTree();
            explain('Leerer Baum', 'Baum wurde geleert. Füge Werte ein, um einen neuen Baum aufzubauen.');
        }

        function resetTree() {
            root = null;
            clearOperationsLog();
            const values = [50, 25, 75, 10, 30, 60, 80, 5, 15];
            values.forEach(v => {
                root = insertSync(root, v);
            });
            centerTree();
            drawTree();
            explain('Reset', 'Baum wurde zurückgesetzt mit Standard-Werten.');
        }

        function randomTree() {
            root = null;
            clearOperationsLog();
            const count = 7 + Math.floor(Math.random() * 6);
            const values = new Set();
            while (values.size < count) {
                values.add(Math.floor(Math.random() * 99) + 1);
            }
            values.forEach(v => {
                root = insertSync(root, v);
            });
            centerTree();
            drawTree();
            explain('Zufällig', `Zufälliger Baum mit ${count} Knoten erstellt.`);
        }

        function insertSync(node, value) {
            if (node === null) {
                return new AVLNode(value);
            }

            if (value < node.value) {
                node.left = insertSync(node.left, value);
            } else if (value > node.value) {
                node.right = insertSync(node.right, value);
            } else {
                return node;
            }

            updateHeight(node);
            const balance = getBalance(node);

            if (balance > 1 && value < node.left.value) {
                return rotateRight(node);
            }

            if (balance < -1 && value > node.right.value) {
                return rotateLeft(node);
            }

            if (balance > 1 && value > node.left.value) {
                node.left = rotateLeft(node.left);
                return rotateRight(node);
            }

            if (balance < -1 && value < node.right.value) {
                node.right = rotateRight(node.right);
                return rotateLeft(node);
            }

            return node;
        }

        function calculatePositions(node, left, right, level) {
            if (node === null) return;

            node.targetX = (left + right) / 2;
            node.targetY = 50 + level * 100;

            // Initialize position for new nodes
            if (node.x === 0 && node.y === 0) {
                node.x = node.targetX;
                node.y = node.targetY;
            }

            const mid = (left + right) / 2;
            if (node.left) calculatePositions(node.left, left, mid, level + 1);
            if (node.right) calculatePositions(node.right, mid, right, level + 1);
        }

        function interpolatePositions(node, progress) {
            if (node === null) return;

            // Smooth interpolation
            const easeProgress = 1 - Math.pow(1 - progress, 3); // Ease out cubic
            node.x += (node.targetX - node.x) * easeProgress;
            node.y += (node.targetY - node.y) * easeProgress;

            if (node.left) interpolatePositions(node.left, progress);
            if (node.right) interpolatePositions(node.right, progress);
        }

        async function animateTree() {
            if (root === null) {
                drawTree();
                return;
            }

            calculatePositions(root, 0, canvas.width, 0);

            // Animate smooth transition
            const steps = 40;
            for (let i = 0; i <= steps; i++) {
                const progress = i / steps;
                interpolatePositions(root, 0.3);
                drawTree();
                await sleep(25); // Slower animation
            }
        }

        function drawTree() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (root === null) return;

            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            drawConnections(root);
            drawNodes(root);

            ctx.restore();
        }

        function drawConnections(node) {
            if (node === null) return;

            ctx.strokeStyle = '#999';
            ctx.lineWidth = 2 / scale;

            if (node.left) {
                ctx.beginPath();
                ctx.moveTo(node.x, node.y);
                ctx.lineTo(node.left.x, node.left.y);
                ctx.stroke();
                drawConnections(node.left);
            }

            if (node.right) {
                ctx.beginPath();
                ctx.moveTo(node.x, node.y);
                ctx.lineTo(node.right.x, node.right.y);
                ctx.stroke();
                drawConnections(node.right);
            }
        }

        function drawNodes(node) {
            if (node === null) return;

            // Draw children first
            if (node.left) drawNodes(node.left);
            if (node.right) drawNodes(node.right);

            const balance = getBalance(node);
            const radius = 30;

            // Draw glow for rotating nodes
            if (node.isRotating) {
                ctx.shadowColor = '#ffc107';
                ctx.shadowBlur = 20;
            } else {
                ctx.shadowBlur = 0;
            }

            // Draw node circle
            ctx.beginPath();
            ctx.arc(node.x, node.y, radius, 0, 2 * Math.PI);

            // Color based on state
            if (node.isRotating) {
                ctx.fillStyle = '#ffc107'; // Yellow for rotating
            } else if (Math.abs(balance) > 1) {
                ctx.fillStyle = '#dc3545'; // Red for unbalanced
            } else if (node.isHighlighted) {
                ctx.fillStyle = '#28a745'; // Green for highlighted
            } else if (node.isNew) {
                ctx.fillStyle = '#17a2b8'; // Cyan for new
            } else {
                ctx.fillStyle = '#667eea'; // Blue for normal
            }

            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2 / scale;
            ctx.stroke();

            ctx.shadowBlur = 0;

            // Draw node value
            ctx.fillStyle = 'white';
            ctx.font = `bold ${Math.round(18 / scale * scale)}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.value, node.x, node.y);

            // Draw height and balance
            ctx.fillStyle = '#333';
            ctx.font = `${Math.round(12 / scale * scale)}px sans-serif`;
            ctx.fillText(`h:${node.height} b:${balance}`, node.x, node.y + 45);
        }

        // Initialize
        initCanvas();
        resetTree();
    </script>
</body>
</html>
