<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Baumstrukturen</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #e4dcf0 0%, #d4cce0 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        .header { text-align: center; margin-bottom: 30px; }
        h1 { color: #333; margin-bottom: 10px; }
        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: #2c3e50;
            text-decoration: none;
            font-weight: bold;
        }
        .back-link:hover { text-decoration: underline; }
        .description {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            line-height: 1.6;
        }
        .section { margin: 40px 0; }
        .section h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }
        .code-block {
            background: #282c34;
            color: #abb2bf;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            margin: 15px 0;
            overflow-x: auto;
            line-height: 1.8;
            white-space: pre-wrap;
        }
        .code-comment { color: #5c6370; }
        .code-keyword { color: #c678dd; }
        .code-function { color: #61afef; }
        .code-number { color: #d19a66; }
        .code-string { color: #98c379; }
        .code-section { margin: 30px 0; }
        .code-section h2 { color: #2c3e50; margin-bottom: 15px; }
        .visualization-container {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 30px;
            margin: 20px 0;
        }
        .canvas-wrapper {
            position: relative;
            width: 100%;
            height: 600px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
            margin: 20px 0;
            background: #fafafa;
        }
        .tree-canvas {
            display: block;
            cursor: grab;
        }
        .tree-canvas:active {
            cursor: grabbing;
        }
        .controls {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
            align-items: center;
        }
        input[type="number"] {
            padding: 10px;
            font-size: 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            width: 100px;
        }
        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            background: #667eea;
            color: white;
        }
        button:hover { background: #5568d3; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .info-box {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
            margin: 20px 0;
        }
        .info-box h3 { color: #333; margin-bottom: 10px; }
        .traversal-output {
            background: #282c34;
            color: #28a745;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            margin: 20px 0;
            min-height: 60px;
        }
        .complexity-badge {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
            margin-left: 10px;
        }
        .badge-good { background: #28a745; color: white; }
        .badge-fair { background: #ffc107; color: #333; }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Zurück zur Übersicht</a>
        <div class="header">
            <h1>Baumstrukturen</h1>
        </div>
        <div class="description">
            <strong>Überblick:</strong> Bäume sind hierarchische Datenstrukturen mit einem Wurzelknoten
            und Kindknoten. Binary Search Trees (BST) sind eine spezielle Form, bei der alle Werte im
            linken Teilbaum kleiner und alle im rechten Teilbaum größer als der Elternknoten sind.
        </div>

        <div class="section">
            <h2>1. Binary Search Tree (BST)</h2>
            <div class="info-box">
                <h3>Eigenschaften:</h3>
                <p><strong>Suche:</strong> <span class="complexity-badge badge-good">O(log n)</span> im Durchschnitt, O(n) im schlechtesten Fall</p>
                <p><strong>Einfügen:</strong> <span class="complexity-badge badge-good">O(log n)</span> im Durchschnitt</p>
                <p><strong>Löschen:</strong> <span class="complexity-badge badge-good">O(log n)</span> im Durchschnitt</p>
                <p><strong>BST-Eigenschaft:</strong> Linker Teilbaum &lt; Wurzel &lt; Rechter Teilbaum</p>
            </div>

            <div class="code-block">
<span class="code-comment"># Tree Node</span>
<span class="code-keyword">class</span> <span class="code-function">TreeNode</span>:
    <span class="code-keyword">def</span> <span class="code-function">__init__</span>(self, value):
        self.value = value
        self.left = <span class="code-keyword">None</span>
        self.right = <span class="code-keyword">None</span>

<span class="code-comment"># BST Einfügen - O(log n)</span>
<span class="code-keyword">def</span> <span class="code-function">insert</span>(root, value):
    <span class="code-keyword">if</span> root <span class="code-keyword">is</span> <span class="code-keyword">None</span>:
        <span class="code-keyword">return</span> TreeNode(value)

    <span class="code-keyword">if</span> value &lt; root.value:
        root.left = insert(root.left, value)
    <span class="code-keyword">elif</span> value &gt; root.value:
        root.right = insert(root.right, value)

    <span class="code-keyword">return</span> root

<span class="code-comment"># BST Suche - O(log n)</span>
<span class="code-keyword">def</span> <span class="code-function">search</span>(root, value):
    <span class="code-keyword">if</span> root <span class="code-keyword">is</span> <span class="code-keyword">None</span> <span class="code-keyword">or</span> root.value == value:
        <span class="code-keyword">return</span> root

    <span class="code-keyword">if</span> value &lt; root.value:
        <span class="code-keyword">return</span> search(root.left, value)

    <span class="code-keyword">return</span> search(root.right, value)
            </div>

            <div class="visualization-container">
                <h3>Interaktive BST Visualisierung</h3>
                <div class="controls">
                    <input type="number" id="treeValue" placeholder="Wert" value="50">
                    <button onclick="insertNode()">Einfügen</button>
                    <button onclick="searchNode()">Suchen</button>
                    <button onclick="handleDeleteNode()">Löschen</button>
                    <button onclick="resetTree()">Reset</button>
                </div>
                <div class="canvas-wrapper">
                    <canvas id="treeCanvas" class="tree-canvas"></canvas>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>2. Tree Traversierung</h2>
            <div class="info-box">
                <h3>Traversierungs-Arten:</h3>
                <ul style="margin-left: 20px; line-height: 2;">
                    <li><strong>Preorder (WLR):</strong> Wurzel → Links → Rechts • Verwendet für Präfix-Notation</li>
                    <li><strong>Inorder (LWR):</strong> Links → Wurzel → Rechts • Ergibt sortierte Reihenfolge bei BST</li>
                    <li><strong>Postorder (LRW):</strong> Links → Rechts → Wurzel • Verwendet für Postfix-Notation</li>
                    <li><strong>Level-Order (Breitensuche):</strong> Ebenenweise von oben nach unten, links nach rechts</li>
                </ul>
            </div>

            <div class="code-block">
<span class="code-comment"># Preorder (WLR): Wurzel → Links → Rechts</span>
<span class="code-keyword">def</span> <span class="code-function">preorder</span>(node):
    <span class="code-keyword">if</span> node <span class="code-keyword">is</span> <span class="code-keyword">None</span>:
        <span class="code-keyword">return</span>

    print(node.value)      <span class="code-comment"># Wurzel</span>
    preorder(node.left)    <span class="code-comment"># Links</span>
    preorder(node.right)   <span class="code-comment"># Rechts</span>

<span class="code-comment"># Inorder (LWR): Links → Wurzel → Rechts</span>
<span class="code-keyword">def</span> <span class="code-function">inorder</span>(node):
    <span class="code-keyword">if</span> node <span class="code-keyword">is</span> <span class="code-keyword">None</span>:
        <span class="code-keyword">return</span>

    inorder(node.left)     <span class="code-comment"># Links</span>
    print(node.value)      <span class="code-comment"># Wurzel</span>
    inorder(node.right)    <span class="code-comment"># Rechts</span>

<span class="code-comment"># Postorder (LRW): Links → Rechts → Wurzel</span>
<span class="code-keyword">def</span> <span class="code-function">postorder</span>(node):
    <span class="code-keyword">if</span> node <span class="code-keyword">is</span> <span class="code-keyword">None</span>:
        <span class="code-keyword">return</span>

    postorder(node.left)   <span class="code-comment"># Links</span>
    postorder(node.right)  <span class="code-comment"># Rechts</span>
    print(node.value)      <span class="code-comment"># Wurzel</span>

<span class="code-comment"># Level-Order (Breitensuche): Ebenenweise</span>
<span class="code-keyword">def</span> <span class="code-function">level_order</span>(root):
    <span class="code-keyword">if</span> root <span class="code-keyword">is</span> <span class="code-keyword">None</span>:
        <span class="code-keyword">return</span>

    queue = [root]

    <span class="code-keyword">while</span> queue:
        node = queue.pop(<span class="code-number">0</span>)
        print(node.value)

        <span class="code-keyword">if</span> node.left:
            queue.append(node.left)
        <span class="code-keyword">if</span> node.right:
            queue.append(node.right)
            </div>

            <div class="visualization-container">
                <h3>Traversierungs-Demo</h3>
                <div class="controls">
                    <button onclick="traversePreorder()">Preorder (WLR)</button>
                    <button onclick="traverseInorder()">Inorder (LWR)</button>
                    <button onclick="traversePostorder()">Postorder (LRW)</button>
                    <button onclick="traverseLevelOrder()">Level-Order</button>
                </div>
                <div class="traversal-output" id="traversalOutput">Wähle eine Traversierungs-Methode...</div>
            </div>
        </div>
    </div>

        <div class="code-section">
            <h2>Implementierung in Python</h2>
            <div class="code-block"><span class="code-comment"># Binary Search Tree in Python</span>

<span class="code-keyword">class</span> <span class="code-function">TreeNode</span>:
    <span class="code-keyword">def</span> <span class="code-function">__init__</span>(self, value):
        self.value, self.left, self.right = value, <span class="code-keyword">None</span>, <span class="code-keyword">None</span>

<span class="code-keyword">class</span> <span class="code-function">BST</span>:
    <span class="code-keyword">def</span> <span class="code-function">__init__</span>(self):
        self.root = <span class="code-keyword">None</span>

    <span class="code-keyword">def</span> <span class="code-function">insert</span>(self, value):
        <span class="code-string">"""Einfügen - O(log n)"""</span>
        self.root = self._insert(self.root, value)

    <span class="code-keyword">def</span> <span class="code-function">_insert</span>(self, node, value):
        <span class="code-keyword">if</span> <span class="code-keyword">not</span> node:
            <span class="code-keyword">return</span> TreeNode(value)
        <span class="code-keyword">if</span> value < node.value:
            node.left = self._insert(node.left, value)
        <span class="code-keyword">elif</span> value > node.value:
            node.right = self._insert(node.right, value)
        <span class="code-keyword">return</span> node

    <span class="code-keyword">def</span> <span class="code-function">search</span>(self, value):
        <span class="code-string">"""Suchen - O(log n)"""</span>
        <span class="code-keyword">return</span> self._search(self.root, value)

    <span class="code-keyword">def</span> <span class="code-function">_search</span>(self, node, value):
        <span class="code-keyword">if</span> <span class="code-keyword">not</span> node <span class="code-keyword">or</span> node.value == value:
            <span class="code-keyword">return</span> node
        <span class="code-keyword">return</span> self._search(node.left, value) <span class="code-keyword">if</span> value < node.value <span class="code-keyword">else</span> self._search(node.right, value)

    <span class="code-keyword">def</span> <span class="code-function">inorder</span>(self, node):
        <span class="code-string">"""Inorder: Links -> Wurzel -> Rechts"""</span>
        <span class="code-keyword">return</span> self.inorder(node.left) + [node.value] + self.inorder(node.right) <span class="code-keyword">if</span> node <span class="code-keyword">else</span> []</div>
        </div>

    <script>
        class TreeNode {
            constructor(value) {
                this.value = value;
                this.left = null;
                this.right = null;
                this.x = 0;
                this.y = 0;
            }
        }

        let root = null;

        // Zoom and Pan variables
        let scale = 1.0;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let lastOffsetX = 0;
        let lastOffsetY = 0;

        function insert(node, value) {
            if (node === null) {
                return new TreeNode(value);
            }
            if (value < node.value) {
                node.left = insert(node.left, value);
            } else if (value > node.value) {
                node.right = insert(node.right, value);
            }
            return node;
        }

        function search(node, value) {
            if (node === null || node.value === value) {
                return node;
            }
            if (value < node.value) {
                return search(node.left, value);
            }
            return search(node.right, value);
        }

        function deleteNode(node, value) {
            if (node === null) return null;

            if (value < node.value) {
                node.left = deleteNode(node.left, value);
            } else if (value > node.value) {
                node.right = deleteNode(node.right, value);
            } else {
                if (node.left === null) return node.right;
                if (node.right === null) return node.left;

                let minNode = findMin(node.right);
                node.value = minNode.value;
                node.right = deleteNode(node.right, minNode.value);
            }
            return node;
        }

        function findMin(node) {
            while (node.left !== null) {
                node = node.left;
            }
            return node;
        }

        function initCanvas() {
            const canvas = document.getElementById('treeCanvas');
            const wrapper = canvas.parentElement;
            canvas.width = wrapper.clientWidth;
            canvas.height = wrapper.clientHeight;
        }

        function centerTree() {
            if (root === null) return;

            const canvas = document.getElementById('treeCanvas');
            calculatePositions(root, 0, canvas.width, 0);

            // Find tree bounds
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;

            function findBounds(node) {
                if (node === null) return;
                minX = Math.min(minX, node.x);
                maxX = Math.max(maxX, node.x);
                minY = Math.min(minY, node.y);
                maxY = Math.max(maxY, node.y);
                findBounds(node.left);
                findBounds(node.right);
            }

            findBounds(root);

            const treeWidth = maxX - minX;
            const treeHeight = maxY - minY;
            const treeCenterX = (minX + maxX) / 2;
            const treeCenterY = (minY + maxY) / 2;

            const canvasCenterX = canvas.width / 2;
            const canvasCenterY = canvas.height / 2;

            const paddingFactor = 0.8;
            const scaleX = (canvas.width * paddingFactor) / (treeWidth + 100);
            const scaleY = (canvas.height * paddingFactor) / (treeHeight + 100);
            scale = Math.min(scaleX, scaleY, 1.5);
            scale = Math.max(scale, 0.3);

            offsetX = canvasCenterX - treeCenterX * scale;
            offsetY = canvasCenterY - treeCenterY * scale;
        }

        function drawTree() {
            const canvas = document.getElementById('treeCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (root === null) return;

            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            calculatePositions(root, 0, canvas.width / scale, 0);
            drawNode(ctx, root);

            ctx.restore();
        }

        function calculatePositions(node, left, right, level) {
            if (node === null) return;

            node.x = (left + right) / 2;
            node.y = 50 + level * 80;

            const mid = (left + right) / 2;
            if (node.left) calculatePositions(node.left, left, mid, level + 1);
            if (node.right) calculatePositions(node.right, mid, right, level + 1);
        }

        function drawNode(ctx, node) {
            if (node === null) return;

            // Draw lines to children
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 2;

            if (node.left) {
                ctx.beginPath();
                ctx.moveTo(node.x, node.y);
                ctx.lineTo(node.left.x, node.left.y);
                ctx.stroke();
                drawNode(ctx, node.left);
            }

            if (node.right) {
                ctx.beginPath();
                ctx.moveTo(node.x, node.y);
                ctx.lineTo(node.right.x, node.right.y);
                ctx.stroke();
                drawNode(ctx, node.right);
            }

            // Draw node circle
            ctx.beginPath();
            ctx.arc(node.x, node.y, 25, 0, 2 * Math.PI);
            ctx.fillStyle = '#667eea';
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw node value
            ctx.fillStyle = 'white';
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.value, node.x, node.y);
        }

        function insertNode() {
            const value = parseInt(document.getElementById('treeValue').value);
            if (!isNaN(value)) {
                root = insert(root, value);
                centerTree();
                drawTree();
            }
        }

        function searchNode() {
            const value = parseInt(document.getElementById('treeValue').value);
            if (!isNaN(value)) {
                const found = search(root, value);
                if (found) {
                    alert(`Wert ${value} gefunden!`);
                } else {
                    alert(`Wert ${value} nicht gefunden!`);
                }
            }
        }

        function handleDeleteNode() {
            const value = parseInt(document.getElementById('treeValue').value);
            if (!isNaN(value)) {
                root = deleteNode(root, value);
                centerTree();
                drawTree();
            }
        }

        function resetTree() {
            root = null;
            root = insert(root, 50);
            root = insert(root, 30);
            root = insert(root, 70);
            root = insert(root, 20);
            root = insert(root, 40);
            root = insert(root, 60);
            root = insert(root, 80);
            centerTree();
            drawTree();
        }

        // Traversals
        function inorderTraversal(node, result) {
            if (node === null) return;
            inorderTraversal(node.left, result);
            result.push(node.value);
            inorderTraversal(node.right, result);
        }

        function preorderTraversal(node, result) {
            if (node === null) return;
            result.push(node.value);
            preorderTraversal(node.left, result);
            preorderTraversal(node.right, result);
        }

        function postorderTraversal(node, result) {
            if (node === null) return;
            postorderTraversal(node.left, result);
            postorderTraversal(node.right, result);
            result.push(node.value);
        }

        function levelOrderTraversal(root) {
            if (root === null) return [];
            const result = [];
            const queue = [root];

            while (queue.length > 0) {
                const node = queue.shift();
                result.push(node.value);

                if (node.left) queue.push(node.left);
                if (node.right) queue.push(node.right);
            }

            return result;
        }

        function traversePreorder() {
            const result = [];
            preorderTraversal(root, result);
            document.getElementById('traversalOutput').textContent = 'Preorder (WLR): ' + result.join(' → ');
        }

        function traverseInorder() {
            const result = [];
            inorderTraversal(root, result);
            document.getElementById('traversalOutput').textContent = 'Inorder (LWR): ' + result.join(' → ');
        }

        function traversePostorder() {
            const result = [];
            postorderTraversal(root, result);
            document.getElementById('traversalOutput').textContent = 'Postorder (LRW): ' + result.join(' → ');
        }

        function traverseLevelOrder() {
            const result = levelOrderTraversal(root);
            document.getElementById('traversalOutput').textContent = 'Level-Order: ' + result.join(' → ');
        }

        // Initialize canvas and event listeners
        const canvas = document.getElementById('treeCanvas');

        initCanvas();

        // Mouse wheel zoom
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = scale * delta;

            if (newScale >= 0.3 && newScale <= 3) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const worldX = (mouseX - offsetX) / scale;
                const worldY = (mouseY - offsetY) / scale;

                scale = newScale;

                offsetX = mouseX - worldX * scale;
                offsetY = mouseY - worldY * scale;

                drawTree();
            }
        });

        // Mouse drag for panning
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            lastOffsetX = offsetX;
            lastOffsetY = offsetY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                offsetX = lastOffsetX + (e.clientX - dragStartX);
                offsetY = lastOffsetY + (e.clientY - dragStartY);
                drawTree();
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        // Touch support for mobile
        let touchStartDist = 0;
        let touchStartScale = 1;

        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                touchStartDist = Math.sqrt(dx * dx + dy * dy);
                touchStartScale = scale;
            } else if (e.touches.length === 1) {
                isDragging = true;
                dragStartX = e.touches[0].clientX;
                dragStartY = e.touches[0].clientY;
                lastOffsetX = offsetX;
                lastOffsetY = offsetY;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const newScale = touchStartScale * (dist / touchStartDist);

                if (newScale >= 0.3 && newScale <= 3) {
                    scale = newScale;
                    drawTree();
                }
            } else if (e.touches.length === 1 && isDragging) {
                offsetX = lastOffsetX + (e.touches[0].clientX - dragStartX);
                offsetY = lastOffsetY + (e.touches[0].clientY - dragStartY);
                drawTree();
            }
        });

        canvas.addEventListener('touchend', () => {
            isDragging = false;
        });

        // Window resize handler
        window.addEventListener('resize', () => {
            initCanvas();
            centerTree();
            drawTree();
        });

        // Initialize
        resetTree();
    </script>
</body>
</html>
