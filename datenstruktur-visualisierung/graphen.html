<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graphen</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #e4dcf0 0%, #d4cce0 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; background: white; border-radius: 20px; padding: 40px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
        .header { text-align: center; margin-bottom: 30px; }
        h1 { color: #333; margin-bottom: 10px; }
        .back-link { display: inline-block; margin-bottom: 20px; color: #333; text-decoration: none; font-weight: bold; }
        .back-link:hover { text-decoration: underline; }
        .description { background: #f8f9fa; padding: 20px; border-radius: 10px; margin-bottom: 30px; line-height: 1.6; }
        .section { margin: 40px 0; }
        .section h2 { color: #333; margin-bottom: 20px; border-bottom: 3px solid #667eea; padding-bottom: 10px; }
        .code-block { background: #282c34; color: #abb2bf; padding: 20px; border-radius: 8px; font-family: 'Courier New', monospace; margin: 15px 0; overflow-x: auto; line-height: 1.8; white-space: pre-wrap; }
        .code-comment { color: #5c6370; }
        .code-keyword { color: #c678dd; }
        .code-function { color: #61afef; }
        .code-number { color: #d19a66; }
        .code-string { color: #98c379; }
        .code-section { margin: 30px 0; }
        .code-section h2 { color: #2c3e50; margin-bottom: 15px; }
        .visualization-container { background: white; border: 2px solid #e0e0e0; border-radius: 10px; padding: 30px; margin: 20px 0; }
        .canvas-wrapper {
            position: relative;
            width: 100%;
            height: 600px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
            margin: 20px 0;
            background: #fafafa;
        }
        .graph-canvas {
            display: block;
            cursor: grab;
        }
        .graph-canvas:active {
            cursor: grabbing;
        }
        .controls { display: flex; gap: 15px; margin: 20px 0; flex-wrap: wrap; align-items: center; }
        input[type="number"] { padding: 10px; font-size: 16px; border: 2px solid #e0e0e0; border-radius: 8px; width: 100px; }
        button { padding: 12px 24px; font-size: 16px; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; transition: all 0.3s; background: #667eea; color: white; }
        button:hover { background: #5568d3; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .info-box { background: #f8f9fa; padding: 20px; border-radius: 10px; border-left: 4px solid #667eea; margin: 20px 0; }
        .info-box h3 { color: #333; margin-bottom: 10px; }
        .complexity-badge { display: inline-block; padding: 5px 15px; border-radius: 20px; font-size: 0.9em; font-weight: bold; margin-left: 10px; }
        .badge-good { background: #28a745; color: white; }
        .badge-fair { background: #ffc107; color: #333; }
        .badge-bad { background: #fd7e14; color: white; }
        .traversal-output { background: #282c34; color: #28a745; padding: 20px; border-radius: 8px; font-family: 'Courier New', monospace; margin: 20px 0; min-height: 60px; }
        .adjacency-matrix { margin: 20px 0; overflow-x: auto; }
        .adjacency-matrix table { border-collapse: collapse; margin: 20px auto; }
        .adjacency-matrix td, .adjacency-matrix th { border: 1px solid #ddd; padding: 10px 15px; text-align: center; min-width: 40px; }
        .adjacency-matrix th { background: #667eea; color: white; font-weight: bold; }
        .adjacency-matrix td { background: white; }
        .adjacency-matrix td.connected { background: #667eea; color: white; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Zurück zur Übersicht</a>
        <div class="header">
            <h1>Graphen</h1>
        </div>
        <div class="description">
            <strong>Überblick:</strong> Graphen bestehen aus Knoten (Vertices) und Kanten (Edges), die
            Verbindungen zwischen Knoten darstellen. Sie können gerichtet oder ungerichtet, gewichtet
            oder ungewichtet sein. Graphen werden verwendet um Netzwerke, Beziehungen, Wege und viele
            andere Strukturen zu modellieren.
        </div>

        <div class="section">
            <h2>1. Graph-Darstellungen</h2>
            <div class="info-box">
                <h3>Zwei Hauptdarstellungen:</h3>
                <ul style="margin-left: 20px; line-height: 2;">
                    <li><strong>Adjazenzliste:</strong> Jeder Knoten hat eine Liste seiner Nachbarn - Speichereffizient für dünnbesetzte Graphen</li>
                    <li><strong>Adjazenzmatrix:</strong> 2D-Array wo [i][j] = 1 wenn Kante von i nach j existiert - Schneller Lookup</li>
                </ul>
            </div>

            <div class="code-block">
<span class="code-comment"># Graph mit Adjazenzliste</span>
<span class="code-keyword">class</span> <span class="code-function">Graph</span>:
    <span class="code-keyword">def</span> <span class="code-function">__init__</span>(self):
        self.adjacency_list = {}

    <span class="code-comment"># Knoten hinzufügen</span>
    <span class="code-keyword">def</span> <span class="code-function">add_vertex</span>(self, vertex):
        <span class="code-keyword">if</span> vertex <span class="code-keyword">not</span> <span class="code-keyword">in</span> self.adjacency_list:
            self.adjacency_list[vertex] = []

    <span class="code-comment"># Kante hinzufügen (ungerichtet)</span>
    <span class="code-keyword">def</span> <span class="code-function">add_edge</span>(self, v1, v2):
        self.adjacency_list[v1].append(v2)
        self.adjacency_list[v2].append(v1)

    <span class="code-comment"># Kante hinzufügen (gerichtet)</span>
    <span class="code-keyword">def</span> <span class="code-function">add_directed_edge</span>(self, from_vertex, to_vertex):
        self.adjacency_list[from_vertex].append(to_vertex)
            </div>

            <div class="visualization-container">
                <h3>Interaktiver Graph</h3>
                <p style="margin-bottom: 15px; color: #666;">Klicke auf die Leinwand um Knoten hinzuzufügen. Wähle zwei Knoten um eine Kante zu erstellen.</p>

                <div class="controls">
                    <button onclick="clearGraph()">Graph leeren</button>
                    <button onclick="createSampleGraph()">Beispiel-Graph</button>
                    <button id="edgeModeBtn" onclick="toggleEdgeMode()">Kanten-Modus: Aus</button>
                </div>

                <div class="canvas-wrapper">
                    <canvas id="graphCanvas" class="graph-canvas"></canvas>
                </div>

                <h4 style="margin-top: 30px;">Adjazenzmatrix:</h4>
                <div class="adjacency-matrix" id="adjacencyMatrix"></div>
            </div>
        </div>

        <div class="section">
            <h2>2. Graph-Traversierung</h2>
            <div class="info-box">
                <h3>Traversierungs-Algorithmen:</h3>
                <ul style="margin-left: 20px; line-height: 2;">
                    <li><strong>BFS (Breadth-First Search):</strong> Ebenenweise Suche mit Queue - <span class="complexity-badge badge-good">O(V + E)</span></li>
                    <li><strong>DFS (Depth-First Search):</strong> Tiefensuche mit Stack/Rekursion - <span class="complexity-badge badge-good">O(V + E)</span></li>
                </ul>
            </div>

            <div class="code-block">
<span class="code-comment"># BFS - Breadth-First Search</span>
<span class="code-keyword">def</span> <span class="code-function">bfs</span>(graph, start):
    visited = set()
    queue = [start]
    result = []

    visited.add(start)

    <span class="code-keyword">while</span> queue:
        vertex = queue.pop(<span class="code-number">0</span>)
        result.append(vertex)

        <span class="code-keyword">for</span> neighbor <span class="code-keyword">in</span> graph.adjacency_list[vertex]:
            <span class="code-keyword">if</span> neighbor <span class="code-keyword">not</span> <span class="code-keyword">in</span> visited:
                visited.add(neighbor)
                queue.append(neighbor)

    <span class="code-keyword">return</span> result

<span class="code-comment"># DFS - Depth-First Search</span>
<span class="code-keyword">def</span> <span class="code-function">dfs</span>(graph, start, visited=<span class="code-keyword">None</span>, result=<span class="code-keyword">None</span>):
    <span class="code-keyword">if</span> visited <span class="code-keyword">is</span> <span class="code-keyword">None</span>:
        visited = set()
    <span class="code-keyword">if</span> result <span class="code-keyword">is</span> <span class="code-keyword">None</span>:
        result = []

    visited.add(start)
    result.append(start)

    <span class="code-keyword">for</span> neighbor <span class="code-keyword">in</span> graph.adjacency_list[start]:
        <span class="code-keyword">if</span> neighbor <span class="code-keyword">not</span> <span class="code-keyword">in</span> visited:
            dfs(graph, neighbor, visited, result)

    <span class="code-keyword">return</span> result
            </div>

            <div class="visualization-container">
                <h3>Traversierungs-Demo</h3>
                <div class="controls">
                    <button onclick="runBFS()">BFS starten</button>
                    <button onclick="runDFS()">DFS starten</button>
                    <button onclick="resetTraversal()">Reset</button>
                </div>
                <div class="traversal-output" id="traversalOutput">Wähle einen Traversierungs-Algorithmus...</div>
            </div>
        </div>
    </div>

        <div class="code-section">
            <h2>Implementierung in Python</h2>
            <div class="code-block"><span class="code-comment"># Graph mit Adjazenzliste</span>

<span class="code-keyword">from</span> collections <span class="code-keyword">import</span> defaultdict, deque

<span class="code-keyword">class</span> <span class="code-function">Graph</span>:
    <span class="code-keyword">def</span> <span class="code-function">__init__</span>(self):
        self.graph = defaultdict(list)

    <span class="code-keyword">def</span> <span class="code-function">add_edge</span>(self, u, v):
        <span class="code-string">"""Kante hinzufügen (ungerichtet)"""</span>
        self.graph[u].append(v)
        self.graph[v].append(u)

    <span class="code-keyword">def</span> <span class="code-function">bfs</span>(self, start):
        <span class="code-string">"""BFS - O(V + E)"""</span>
        visited = set([start])
        queue = deque([start])
        result = []

        <span class="code-keyword">while</span> queue:
            vertex = queue.popleft()
            result.append(vertex)
            <span class="code-keyword">for</span> neighbor <span class="code-keyword">in</span> self.graph[vertex]:
                <span class="code-keyword">if</span> neighbor <span class="code-keyword">not</span> <span class="code-keyword">in</span> visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
        <span class="code-keyword">return</span> result

    <span class="code-keyword">def</span> <span class="code-function">dfs</span>(self, start, visited=<span class="code-keyword">None</span>):
        <span class="code-string">"""DFS - O(V + E)"""</span>
        <span class="code-keyword">if</span> visited <span class="code-keyword">is</span> <span class="code-keyword">None</span>:
            visited = set()
        visited.add(start)
        result = [start]
        <span class="code-keyword">for</span> neighbor <span class="code-keyword">in</span> self.graph[start]:
            <span class="code-keyword">if</span> neighbor <span class="code-keyword">not</span> <span class="code-keyword">in</span> visited:
                result.extend(self.dfs(neighbor, visited))
        <span class="code-keyword">return</span> result</div>
        </div>

    <script>
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');

        // Zoom and Pan variables
        let scale = 1.0;
        let offsetX = 0;
        let offsetY = 0;
        let isDraggingCanvas = false;
        let hasDragged = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let lastOffsetX = 0;
        let lastOffsetY = 0;

        class GraphNode {
            constructor(id, x, y) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.radius = 25;
            }

            draw(color = '#667eea', textColor = 'white') {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
                ctx.fillStyle = color;
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = textColor;
                ctx.font = 'bold 16px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.id, this.x, this.y);
            }

            contains(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                return dx * dx + dy * dy <= this.radius * this.radius;
            }
        }

        let nodes = [];
        let edges = [];
        let nodeCounter = 0;
        let selectedNode = null;
        let edgeMode = false;

        function initCanvas() {
            const wrapper = canvas.parentElement;
            canvas.width = wrapper.clientWidth;
            canvas.height = wrapper.clientHeight;
        }

        function centerGraph() {
            if (nodes.length === 0) return;

            // Find bounds
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;

            nodes.forEach(node => {
                minX = Math.min(minX, node.x);
                maxX = Math.max(maxX, node.x);
                minY = Math.min(minY, node.y);
                maxY = Math.max(maxY, node.y);
            });

            const graphWidth = maxX - minX;
            const graphHeight = maxY - minY;
            const graphCenterX = (minX + maxX) / 2;
            const graphCenterY = (minY + maxY) / 2;

            const canvasCenterX = canvas.width / 2;
            const canvasCenterY = canvas.height / 2;

            const paddingFactor = 0.8;
            const scaleX = (canvas.width * paddingFactor) / (graphWidth + 100);
            const scaleY = (canvas.height * paddingFactor) / (graphHeight + 100);
            scale = Math.min(scaleX, scaleY, 1.5);
            scale = Math.max(scale, 0.3);

            offsetX = canvasCenterX - graphCenterX * scale;
            offsetY = canvasCenterY - graphCenterY * scale;
        }

        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            // Draw edges
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 2;
            edges.forEach(([from, to]) => {
                const fromNode = nodes.find(n => n.id === from);
                const toNode = nodes.find(n => n.id === to);
                if (fromNode && toNode) {
                    ctx.beginPath();
                    ctx.moveTo(fromNode.x, fromNode.y);
                    ctx.lineTo(toNode.x, toNode.y);
                    ctx.stroke();
                }
            });

            // Draw nodes
            nodes.forEach(node => {
                const color = node === selectedNode ? '#ffc107' : '#667eea';
                node.draw(color);
            });

            ctx.restore();
        }

        canvas.addEventListener('click', (e) => {
            if (hasDragged) {
                hasDragged = false;
                return; // Don't register clicks after dragging
            }

            const rect = canvas.getBoundingClientRect();
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;

            // Transform to world coordinates
            const x = (canvasX - offsetX) / scale;
            const y = (canvasY - offsetY) / scale;

            const clickedNode = nodes.find(node => node.contains(x, y));

            if (edgeMode && clickedNode) {
                if (selectedNode === null) {
                    selectedNode = clickedNode;
                } else {
                    if (selectedNode !== clickedNode) {
                        edges.push([selectedNode.id, clickedNode.id]);
                        updateAdjacencyMatrix();
                    }
                    selectedNode = null;
                }
            } else if (!clickedNode) {
                const newNode = new GraphNode(nodeCounter++, x, y);
                nodes.push(newNode);
                updateAdjacencyMatrix();
            } else {
                selectedNode = clickedNode === selectedNode ? null : clickedNode;
            }

            drawGraph();
        });

        function toggleEdgeMode() {
            edgeMode = !edgeMode;
            selectedNode = null;
            const btn = document.getElementById('edgeModeBtn');
            btn.textContent = `Kanten-Modus: ${edgeMode ? 'An' : 'Aus'}`;
            btn.style.background = edgeMode ? '#28a745' : '#667eea';
            drawGraph();
        }

        function clearGraph() {
            nodes = [];
            edges = [];
            nodeCounter = 0;
            selectedNode = null;
            drawGraph();
            updateAdjacencyMatrix();
        }

        function createSampleGraph() {
            clearGraph();
            nodes = [
                new GraphNode(0, 150, 100),
                new GraphNode(1, 300, 100),
                new GraphNode(2, 450, 100),
                new GraphNode(3, 225, 250),
                new GraphNode(4, 375, 250)
            ];
            nodeCounter = 5;

            edges = [
                [0, 1], [1, 2], [0, 3], [1, 3], [1, 4], [2, 4], [3, 4]
            ];

            centerGraph();
            drawGraph();
            updateAdjacencyMatrix();
        }

        function updateAdjacencyMatrix() {
            const container = document.getElementById('adjacencyMatrix');
            if (nodes.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666;">Keine Knoten vorhanden</p>';
                return;
            }

            let html = '<table><tr><th></th>';
            nodes.forEach(node => {
                html += `<th>${node.id}</th>`;
            });
            html += '</tr>';

            nodes.forEach(fromNode => {
                html += `<tr><th>${fromNode.id}</th>`;
                nodes.forEach(toNode => {
                    const hasEdge = edges.some(([from, to]) =>
                        (from === fromNode.id && to === toNode.id) ||
                        (from === toNode.id && to === fromNode.id)
                    );
                    html += `<td class="${hasEdge ? 'connected' : ''}">${hasEdge ? '1' : '0'}</td>`;
                });
                html += '</tr>';
            });
            html += '</table>';

            container.innerHTML = html;
        }

        async function runBFS() {
            if (nodes.length === 0) {
                alert('Erstelle zuerst einen Graphen!');
                return;
            }

            const visited = new Set();
            const queue = [nodes[0].id];
            const result = [];

            visited.add(nodes[0].id);

            while (queue.length > 0) {
                const currentId = queue.shift();
                result.push(currentId);

                const node = nodes.find(n => n.id === currentId);
                node.draw('#28a745');
                await sleep(500);

                const neighbors = edges
                    .filter(([from, to]) => from === currentId || to === currentId)
                    .map(([from, to]) => from === currentId ? to : from);

                for (const neighborId of neighbors) {
                    if (!visited.has(neighborId)) {
                        visited.add(neighborId);
                        queue.push(neighborId);
                    }
                }
            }

            document.getElementById('traversalOutput').textContent =
                'BFS Reihenfolge: ' + result.join(' → ');
        }

        async function runDFS() {
            if (nodes.length === 0) {
                alert('Erstelle zuerst einen Graphen!');
                return;
            }

            const visited = new Set();
            const result = [];

            async function dfsVisit(nodeId) {
                visited.add(nodeId);
                result.push(nodeId);

                const node = nodes.find(n => n.id === nodeId);
                node.draw('#28a745');
                await sleep(500);

                const neighbors = edges
                    .filter(([from, to]) => from === nodeId || to === nodeId)
                    .map(([from, to]) => from === nodeId ? to : from);

                for (const neighborId of neighbors) {
                    if (!visited.has(neighborId)) {
                        await dfsVisit(neighborId);
                    }
                }
            }

            await dfsVisit(nodes[0].id);

            document.getElementById('traversalOutput').textContent =
                'DFS Reihenfolge: ' + result.join(' → ');
        }

        function resetTraversal() {
            drawGraph();
            document.getElementById('traversalOutput').textContent =
                'Wähle einen Traversierungs-Algorithmus...';
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Initialize canvas
        initCanvas();

        // Mouse wheel zoom
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = scale * delta;

            if (newScale >= 0.3 && newScale <= 3) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const worldX = (mouseX - offsetX) / scale;
                const worldY = (mouseY - offsetY) / scale;

                scale = newScale;

                offsetX = mouseX - worldX * scale;
                offsetY = mouseY - worldY * scale;

                drawGraph();
            }
        });

        // Mouse drag for panning
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - offsetX) / scale;
            const y = (e.clientY - rect.top - offsetY) / scale;
            const clickedNode = nodes.find(node => node.contains(x, y));

            // Only start dragging if not clicking on a node
            if (!clickedNode) {
                isDraggingCanvas = true;
                hasDragged = false;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                lastOffsetX = offsetX;
                lastOffsetY = offsetY;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDraggingCanvas) {
                const dx = e.clientX - dragStartX;
                const dy = e.clientY - dragStartY;

                // Mark as dragged if moved more than 3 pixels
                if (Math.abs(dx) > 3 || Math.abs(dy) > 3) {
                    hasDragged = true;
                }

                offsetX = lastOffsetX + dx;
                offsetY = lastOffsetY + dy;
                drawGraph();
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDraggingCanvas = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDraggingCanvas = false;
        });

        // Touch support for mobile
        let touchStartDist = 0;
        let touchStartScale = 1;

        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                touchStartDist = Math.sqrt(dx * dx + dy * dy);
                touchStartScale = scale;
            } else if (e.touches.length === 1) {
                const rect = canvas.getBoundingClientRect();
                const x = (e.touches[0].clientX - rect.left - offsetX) / scale;
                const y = (e.touches[0].clientY - rect.top - offsetY) / scale;
                const touchedNode = nodes.find(node => node.contains(x, y));

                if (!touchedNode) {
                    isDraggingCanvas = true;
                    hasDragged = false;
                    dragStartX = e.touches[0].clientX;
                    dragStartY = e.touches[0].clientY;
                    lastOffsetX = offsetX;
                    lastOffsetY = offsetY;
                }
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const newScale = touchStartScale * (dist / touchStartDist);

                if (newScale >= 0.3 && newScale <= 3) {
                    scale = newScale;
                    drawGraph();
                }
            } else if (e.touches.length === 1 && isDraggingCanvas) {
                const dx = e.touches[0].clientX - dragStartX;
                const dy = e.touches[0].clientY - dragStartY;

                // Mark as dragged if moved more than 3 pixels
                if (Math.abs(dx) > 3 || Math.abs(dy) > 3) {
                    hasDragged = true;
                }

                offsetX = lastOffsetX + dx;
                offsetY = lastOffsetY + dy;
                drawGraph();
            }
        });

        canvas.addEventListener('touchend', () => {
            isDraggingCanvas = false;
        });

        // Window resize handler
        window.addEventListener('resize', () => {
            initCanvas();
            centerGraph();
            drawGraph();
        });

        // Initialize
        createSampleGraph();
    </script>
</body>
</html>
