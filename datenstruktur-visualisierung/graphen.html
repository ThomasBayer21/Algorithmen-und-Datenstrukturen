<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graphen</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f5f5f5; min-height: 100vh; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; background: white; border-radius: 12px; padding: 40px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); }
        .header { text-align: center; margin-bottom: 30px; }
        h1 { color: #333; margin-bottom: 10px; }
        .back-link { display: inline-block; margin-bottom: 20px; color: #333; text-decoration: none; font-weight: bold; }
        .back-link:hover { text-decoration: underline; }
        .description { background: #f8f9fa; padding: 20px; border-radius: 10px; margin-bottom: 30px; line-height: 1.6; }
        .section { margin: 40px 0; }
        .section h2 { color: #333; margin-bottom: 20px; border-bottom: 3px solid #667eea; padding-bottom: 10px; }
        .code-block { background: #282c34; color: #abb2bf; padding: 20px; border-radius: 8px; font-family: 'Courier New', monospace; margin: 15px 0; overflow-x: auto; line-height: 1.8; white-space: pre-wrap; }
        .code-comment { color: #5c6370; }
        .code-keyword { color: #c678dd; }
        .code-function { color: #61afef; }
        .code-number { color: #d19a66; }
        .visualization-container { background: white; border: 2px solid #e0e0e0; border-radius: 10px; padding: 30px; margin: 20px 0; }
        .graph-canvas { border: 1px solid #e0e0e0; border-radius: 8px; display: block; margin: 20px auto; cursor: pointer; }
        .controls { display: flex; gap: 15px; margin: 20px 0; flex-wrap: wrap; align-items: center; }
        input[type="number"] { padding: 10px; font-size: 16px; border: 2px solid #e0e0e0; border-radius: 8px; width: 100px; }
        button { padding: 12px 24px; font-size: 16px; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; transition: all 0.3s; background: #667eea; color: white; }
        button:hover { background: #5568d3; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .info-box { background: #f8f9fa; padding: 20px; border-radius: 10px; border-left: 4px solid #667eea; margin: 20px 0; }
        .info-box h3 { color: #333; margin-bottom: 10px; }
        .complexity-badge { display: inline-block; padding: 5px 15px; border-radius: 20px; font-size: 0.9em; font-weight: bold; margin-left: 10px; }
        .badge-good { background: #28a745; color: white; }
        .badge-fair { background: #ffc107; color: #333; }
        .badge-bad { background: #fd7e14; color: white; }
        .traversal-output { background: #282c34; color: #28a745; padding: 20px; border-radius: 8px; font-family: 'Courier New', monospace; margin: 20px 0; min-height: 60px; }
        .adjacency-matrix { margin: 20px 0; overflow-x: auto; }
        .adjacency-matrix table { border-collapse: collapse; margin: 20px auto; }
        .adjacency-matrix td, .adjacency-matrix th { border: 1px solid #ddd; padding: 10px 15px; text-align: center; min-width: 40px; }
        .adjacency-matrix th { background: #667eea; color: white; font-weight: bold; }
        .adjacency-matrix td { background: white; }
        .adjacency-matrix td.connected { background: #667eea; color: white; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Zurück zur Übersicht</a>
        <div class="header">
            <h1>Graphen</h1>
        </div>
        <div class="description">
            <strong>Überblick:</strong> Graphen bestehen aus Knoten (Vertices) und Kanten (Edges), die
            Verbindungen zwischen Knoten darstellen. Sie können gerichtet oder ungerichtet, gewichtet
            oder ungewichtet sein. Graphen werden verwendet um Netzwerke, Beziehungen, Wege und viele
            andere Strukturen zu modellieren.
        </div>

        <div class="section">
            <h2>1. Graph-Darstellungen</h2>
            <div class="info-box">
                <h3>Zwei Hauptdarstellungen:</h3>
                <ul style="margin-left: 20px; line-height: 2;">
                    <li><strong>Adjazenzliste:</strong> Jeder Knoten hat eine Liste seiner Nachbarn - Speichereffizient für dünnbesetzte Graphen</li>
                    <li><strong>Adjazenzmatrix:</strong> 2D-Array wo [i][j] = 1 wenn Kante von i nach j existiert - Schneller Lookup</li>
                </ul>
            </div>

            <div class="code-block">
<span class="code-comment">// Graph mit Adjazenzliste</span>
<span class="code-keyword">class</span> <span class="code-function">Graph</span> {
    <span class="code-function">constructor</span>() {
        <span class="code-keyword">this</span>.adjacencyList = <span class="code-keyword">new</span> <span class="code-function">Map</span>();
    }

    <span class="code-comment">// Knoten hinzufügen</span>
    <span class="code-function">addVertex</span>(vertex) {
        <span class="code-keyword">if</span> (!<span class="code-keyword">this</span>.adjacencyList.has(vertex)) {
            <span class="code-keyword">this</span>.adjacencyList.set(vertex, []);
        }
    }

    <span class="code-comment">// Kante hinzufügen (ungerichtet)</span>
    <span class="code-function">addEdge</span>(v1, v2) {
        <span class="code-keyword">this</span>.adjacencyList.get(v1).push(v2);
        <span class="code-keyword">this</span>.adjacencyList.get(v2).push(v1);
    }

    <span class="code-comment">// Kante hinzufügen (gerichtet)</span>
    <span class="code-function">addDirectedEdge</span>(from, to) {
        <span class="code-keyword">this</span>.adjacencyList.get(from).push(to);
    }
}
            </div>

            <div class="visualization-container">
                <h3>Interaktiver Graph</h3>
                <p style="margin-bottom: 15px; color: #666;">Klicke auf die Leinwand um Knoten hinzuzufügen. Wähle zwei Knoten um eine Kante zu erstellen.</p>

                <div class="controls">
                    <button onclick="clearGraph()">Graph leeren</button>
                    <button onclick="createSampleGraph()">Beispiel-Graph</button>
                    <button id="edgeModeBtn" onclick="toggleEdgeMode()">Kanten-Modus: Aus</button>
                </div>

                <canvas id="graphCanvas" class="graph-canvas" width="800" height="400"></canvas>

                <h4 style="margin-top: 30px;">Adjazenzmatrix:</h4>
                <div class="adjacency-matrix" id="adjacencyMatrix"></div>
            </div>
        </div>

        <div class="section">
            <h2>2. Graph-Traversierung</h2>
            <div class="info-box">
                <h3>Traversierungs-Algorithmen:</h3>
                <ul style="margin-left: 20px; line-height: 2;">
                    <li><strong>BFS (Breadth-First Search):</strong> Ebenenweise Suche mit Queue - <span class="complexity-badge badge-good">O(V + E)</span></li>
                    <li><strong>DFS (Depth-First Search):</strong> Tiefensuche mit Stack/Rekursion - <span class="complexity-badge badge-good">O(V + E)</span></li>
                </ul>
            </div>

            <div class="code-block">
<span class="code-comment">// BFS - Breadth-First Search</span>
<span class="code-keyword">function</span> <span class="code-function">bfs</span>(graph, start) {
    <span class="code-keyword">const</span> visited = <span class="code-keyword">new</span> <span class="code-function">Set</span>();
    <span class="code-keyword">const</span> queue = [start];
    <span class="code-keyword">const</span> result = [];

    visited.add(start);

    <span class="code-keyword">while</span> (queue.length &gt; <span class="code-number">0</span>) {
        <span class="code-keyword">const</span> vertex = queue.shift();
        result.push(vertex);

        <span class="code-keyword">for</span> (<span class="code-keyword">const</span> neighbor <span class="code-keyword">of</span> graph.adjacencyList.get(vertex)) {
            <span class="code-keyword">if</span> (!visited.has(neighbor)) {
                visited.add(neighbor);
                queue.push(neighbor);
            }
        }
    }

    <span class="code-keyword">return</span> result;
}

<span class="code-comment">// DFS - Depth-First Search</span>
<span class="code-keyword">function</span> <span class="code-function">dfs</span>(graph, start, visited = <span class="code-keyword">new</span> <span class="code-function">Set</span>(), result = []) {
    visited.add(start);
    result.push(start);

    <span class="code-keyword">for</span> (<span class="code-keyword">const</span> neighbor <span class="code-keyword">of</span> graph.adjacencyList.get(start)) {
        <span class="code-keyword">if</span> (!visited.has(neighbor)) {
            <span class="code-function">dfs</span>(graph, neighbor, visited, result);
        }
    }

    <span class="code-keyword">return</span> result;
}
            </div>

            <div class="visualization-container">
                <h3>Traversierungs-Demo</h3>
                <div class="controls">
                    <button onclick="runBFS()">BFS starten</button>
                    <button onclick="runDFS()">DFS starten</button>
                    <button onclick="resetTraversal()">Reset</button>
                </div>
                <div class="traversal-output" id="traversalOutput">Wähle einen Traversierungs-Algorithmus...</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');

        class GraphNode {
            constructor(id, x, y) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.radius = 25;
            }

            draw(color = '#667eea', textColor = 'white') {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
                ctx.fillStyle = color;
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = textColor;
                ctx.font = 'bold 16px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.id, this.x, this.y);
            }

            contains(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                return dx * dx + dy * dy <= this.radius * this.radius;
            }
        }

        let nodes = [];
        let edges = [];
        let nodeCounter = 0;
        let selectedNode = null;
        let edgeMode = false;

        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw edges
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 2;
            edges.forEach(([from, to]) => {
                const fromNode = nodes.find(n => n.id === from);
                const toNode = nodes.find(n => n.id === to);
                if (fromNode && toNode) {
                    ctx.beginPath();
                    ctx.moveTo(fromNode.x, fromNode.y);
                    ctx.lineTo(toNode.x, toNode.y);
                    ctx.stroke();
                }
            });

            // Draw nodes
            nodes.forEach(node => {
                const color = node === selectedNode ? '#ffc107' : '#667eea';
                node.draw(color);
            });
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const clickedNode = nodes.find(node => node.contains(x, y));

            if (edgeMode && clickedNode) {
                if (selectedNode === null) {
                    selectedNode = clickedNode;
                } else {
                    if (selectedNode !== clickedNode) {
                        edges.push([selectedNode.id, clickedNode.id]);
                        updateAdjacencyMatrix();
                    }
                    selectedNode = null;
                }
            } else if (!clickedNode) {
                const newNode = new GraphNode(nodeCounter++, x, y);
                nodes.push(newNode);
                updateAdjacencyMatrix();
            } else {
                selectedNode = clickedNode === selectedNode ? null : clickedNode;
            }

            drawGraph();
        });

        function toggleEdgeMode() {
            edgeMode = !edgeMode;
            selectedNode = null;
            const btn = document.getElementById('edgeModeBtn');
            btn.textContent = `Kanten-Modus: ${edgeMode ? 'An' : 'Aus'}`;
            btn.style.background = edgeMode ? '#28a745' : '#667eea';
            drawGraph();
        }

        function clearGraph() {
            nodes = [];
            edges = [];
            nodeCounter = 0;
            selectedNode = null;
            drawGraph();
            updateAdjacencyMatrix();
        }

        function createSampleGraph() {
            clearGraph();
            nodes = [
                new GraphNode(0, 150, 100),
                new GraphNode(1, 300, 100),
                new GraphNode(2, 450, 100),
                new GraphNode(3, 225, 250),
                new GraphNode(4, 375, 250)
            ];
            nodeCounter = 5;

            edges = [
                [0, 1], [1, 2], [0, 3], [1, 3], [1, 4], [2, 4], [3, 4]
            ];

            drawGraph();
            updateAdjacencyMatrix();
        }

        function updateAdjacencyMatrix() {
            const container = document.getElementById('adjacencyMatrix');
            if (nodes.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666;">Keine Knoten vorhanden</p>';
                return;
            }

            let html = '<table><tr><th></th>';
            nodes.forEach(node => {
                html += `<th>${node.id}</th>`;
            });
            html += '</tr>';

            nodes.forEach(fromNode => {
                html += `<tr><th>${fromNode.id}</th>`;
                nodes.forEach(toNode => {
                    const hasEdge = edges.some(([from, to]) =>
                        (from === fromNode.id && to === toNode.id) ||
                        (from === toNode.id && to === fromNode.id)
                    );
                    html += `<td class="${hasEdge ? 'connected' : ''}">${hasEdge ? '1' : '0'}</td>`;
                });
                html += '</tr>';
            });
            html += '</table>';

            container.innerHTML = html;
        }

        async function runBFS() {
            if (nodes.length === 0) {
                alert('Erstelle zuerst einen Graphen!');
                return;
            }

            const visited = new Set();
            const queue = [nodes[0].id];
            const result = [];

            visited.add(nodes[0].id);

            while (queue.length > 0) {
                const currentId = queue.shift();
                result.push(currentId);

                const node = nodes.find(n => n.id === currentId);
                node.draw('#28a745');
                await sleep(500);

                const neighbors = edges
                    .filter(([from, to]) => from === currentId || to === currentId)
                    .map(([from, to]) => from === currentId ? to : from);

                for (const neighborId of neighbors) {
                    if (!visited.has(neighborId)) {
                        visited.add(neighborId);
                        queue.push(neighborId);
                    }
                }
            }

            document.getElementById('traversalOutput').textContent =
                'BFS Reihenfolge: ' + result.join(' → ');
        }

        async function runDFS() {
            if (nodes.length === 0) {
                alert('Erstelle zuerst einen Graphen!');
                return;
            }

            const visited = new Set();
            const result = [];

            async function dfsVisit(nodeId) {
                visited.add(nodeId);
                result.push(nodeId);

                const node = nodes.find(n => n.id === nodeId);
                node.draw('#28a745');
                await sleep(500);

                const neighbors = edges
                    .filter(([from, to]) => from === nodeId || to === nodeId)
                    .map(([from, to]) => from === nodeId ? to : from);

                for (const neighborId of neighbors) {
                    if (!visited.has(neighborId)) {
                        await dfsVisit(neighborId);
                    }
                }
            }

            await dfsVisit(nodes[0].id);

            document.getElementById('traversalOutput').textContent =
                'DFS Reihenfolge: ' + result.join(' → ');
        }

        function resetTraversal() {
            drawGraph();
            document.getElementById('traversalOutput').textContent =
                'Wähle einen Traversierungs-Algorithmus...';
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Initialize
        createSampleGraph();
    </script>
</body>
</html>
