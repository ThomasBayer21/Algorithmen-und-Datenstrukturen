<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teile und Beherrsche - Maximum Subarray</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: #333;
            text-decoration: none;
            font-weight: bold;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        .description {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .section {
            margin: 40px 0;
        }

        .section h2 {
            color: #333;
            margin-bottom: 20px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .code-block {
            background: #282c34;
            color: #abb2bf;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            margin: 15px 0;
            overflow-x: auto;
            line-height: 1.8;
            white-space: pre-wrap;
        }

        .code-comment {
            color: #5c6370;
        }

        .code-keyword {
            color: #c678dd;
        }

        .code-function {
            color: #61afef;
        }

        .code-number {
            color: #d19a66;
        }

        .visualization-container {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 30px;
            margin: 20px 0;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
            align-items: center;
        }

        input[type="text"] {
            padding: 10px;
            font-size: 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            min-width: 250px;
        }

        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            background: #667eea;
            color: white;
        }

        button:hover {
            background: #5568d3;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .info-box {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
            margin: 20px 0;
        }

        .info-box h3 {
            color: #333;
            margin-bottom: 10px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            color: #666;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .array-display {
            display: flex;
            justify-content: center;
            gap: 5px;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .array-element {
            background: #e0e0e0;
            padding: 15px 20px;
            border-radius: 8px;
            font-size: 1.2em;
            font-weight: bold;
            min-width: 60px;
            text-align: center;
            transition: all 0.3s;
            position: relative;
        }

        .array-element.positive {
            background: #d4edda;
            color: #155724;
        }

        .array-element.negative {
            background: #f8d7da;
            color: #721c24;
        }

        .array-element.left-half {
            border: 3px solid #ff6b6b;
        }

        .array-element.right-half {
            border: 3px solid #4ecdc4;
        }

        .array-element.crossing {
            border: 3px solid #ffd93d;
            background: #fff9e6;
        }

        .array-element.best {
            background: #28a745;
            color: white;
            box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.5);
            animation: pulse 1s ease infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .recursion-tree {
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            overflow-x: auto;
        }

        .tree-node {
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 15px;
            margin: 10px;
            display: inline-block;
            min-width: 200px;
            text-align: center;
            transition: all 0.3s;
        }

        .tree-node.active {
            background: #667eea;
            color: white;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
        }

        .tree-node.completed {
            background: #28a745;
            color: white;
            border-color: #28a745;
        }

        .tree-level {
            margin: 20px 0;
            text-align: center;
        }

        .tree-connector {
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .tree-connector svg {
            width: 100%;
            height: 100px;
        }

        .step-info {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            text-align: center;
            font-weight: bold;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .result-box {
            background: #fff9e6;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
            font-size: 1.2em;
            border: 2px solid #ffc107;
        }

        .algorithm-comparison {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .algorithm-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e0e0e0;
        }

        .algorithm-card h3 {
            color: #333;
            margin-bottom: 15px;
            text-align: center;
        }

        .complexity-badge {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            margin: 5px;
        }

        .complexity-good {
            background: #d4edda;
            color: #155724;
        }

        .complexity-medium {
            background: #fff3cd;
            color: #856404;
        }

        .complexity-bad {
            background: #f8d7da;
            color: #721c24;
        }

        .legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .legend-box {
            width: 30px;
            height: 30px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Zurück zur Übersicht</a>

        <div class="header">
            <h1>Teile und Beherrsche (Divide and Conquer)</h1>
            <h2 style="color: #666; font-size: 1.2em; margin-top: 10px;">Maximum Subarray Problem</h2>
        </div>

        <div class="description">
            <strong>Überblick:</strong> Teile und Beherrsche ist ein fundamentales algorithmisches Paradigma,
            bei dem ein Problem rekursiv in kleinere Teilprobleme zerlegt wird, diese gelöst werden, und dann
            die Teillösungen zu einer Gesamtlösung kombiniert werden. Am Beispiel des Maximum Subarray Problems
            wird die Effizienz und Eleganz dieser Methode demonstriert.
        </div>

        <div class="section">
            <h2>Das Teile-und-Beherrsche-Prinzip</h2>

            <div class="info-box">
                <h3>Drei Grundschritte:</h3>
                <ol style="margin-left: 20px; margin-top: 10px; line-height: 1.8;">
                    <li><strong>Teile (Divide):</strong> Zerlege das Problem in kleinere Teilprobleme derselben Art</li>
                    <li><strong>Beherrsche (Conquer):</strong> Löse die Teilprobleme rekursiv. Bei kleinen Problemen löse direkt</li>
                    <li><strong>Kombiniere (Combine):</strong> Füge die Teillösungen zur Gesamtlösung zusammen</li>
                </ol>
            </div>

            <div class="info-box">
                <h3>Anwendung auf Maximum Subarray:</h3>
                <ol style="margin-left: 20px; margin-top: 10px; line-height: 1.8;">
                    <li><strong>Teile:</strong> Teile das Array in zwei Hälften an der Mitte</li>
                    <li><strong>Beherrsche:</strong> Finde rekursiv das Maximum Subarray in:
                        <ul style="margin-left: 20px; margin-top: 5px;">
                            <li>Der linken Hälfte</li>
                            <li>Der rechten Hälfte</li>
                            <li>Über die Mitte hinweg (crossing)</li>
                        </ul>
                    </li>
                    <li><strong>Kombiniere:</strong> Wähle das Maximum der drei Möglichkeiten</li>
                </ol>
            </div>
        </div>

        <div class="section">
            <h2>Interaktive Visualisierung</h2>

            <div class="visualization-container">
                <div class="controls">
                    <input type="text" id="arrayInput" placeholder="z.B. -2,1,-3,4,-1,2,1,-5,4" value="-2,1,-3,4,-1,2,1,-5,4">
                    <button onclick="startDivideConquer()">Divide & Conquer starten</button>
                    <button onclick="stopAlgorithm()">Stop</button>
                </div>

                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-box" style="border: 3px solid #ff6b6b; background: white;"></div>
                        <span>Linke Hälfte</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-box" style="border: 3px solid #4ecdc4; background: white;"></div>
                        <span>Rechte Hälfte</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-box" style="background: #fff9e6; border: 3px solid #ffd93d;"></div>
                        <span>Crossing Middle</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-box" style="background: #28a745;"></div>
                        <span>Beste Lösung</span>
                    </div>
                </div>

                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-value" id="arrayLength">-</div>
                        <div class="stat-label">Array Länge</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="recursionDepth">0</div>
                        <div class="stat-label">Rekursionstiefe</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="recursiveCalls">0</div>
                        <div class="stat-label">Rekursive Aufrufe</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="maxSum">-</div>
                        <div class="stat-label">Maximale Summe</div>
                    </div>
                </div>

                <div class="step-info" id="stepInfo">
                    Bereit zum Start
                </div>

                <h3 style="text-align: center; margin: 20px 0;">Array</h3>
                <div class="array-display" id="arrayDisplay"></div>

                <div class="result-box" id="resultBox" style="display: none;">
                    Ergebnis wird hier angezeigt
                </div>

                <h3 style="text-align: center; margin: 30px 0;">Rekursionsbaum</h3>
                <div class="recursion-tree" id="recursionTree">
                    <div style="text-align: center; color: #666;">Rekursionsbaum wird während der Ausführung angezeigt</div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>Code-Implementierung</h2>

            <div class="code-block">
<span class="code-keyword">function</span> <span class="code-function">maxSubarrayDivideConquer</span>(arr, low = <span class="code-number">0</span>, high = arr.length - <span class="code-number">1</span>) {
    <span class="code-comment">// Basisfall: Nur ein Element</span>
    <span class="code-keyword">if</span> (low === high) {
        <span class="code-keyword">return</span> {
            sum: arr[low],
            left: low,
            right: high
        };
    }

    <span class="code-comment">// Teile: Finde die Mitte</span>
    <span class="code-keyword">const</span> mid = Math.floor((low + high) / <span class="code-number">2</span>);

    <span class="code-comment">// Beherrsche: Rekursive Aufrufe</span>
    <span class="code-keyword">const</span> leftResult = <span class="code-function">maxSubarrayDivideConquer</span>(arr, low, mid);
    <span class="code-keyword">const</span> rightResult = <span class="code-function">maxSubarrayDivideConquer</span>(arr, mid + <span class="code-number">1</span>, high);
    <span class="code-keyword">const</span> crossResult = <span class="code-function">maxCrossingSubarray</span>(arr, low, mid, high);

    <span class="code-comment">// Kombiniere: Wähle das Maximum</span>
    <span class="code-keyword">if</span> (leftResult.sum >= rightResult.sum && leftResult.sum >= crossResult.sum) {
        <span class="code-keyword">return</span> leftResult;
    } <span class="code-keyword">else if</span> (rightResult.sum >= leftResult.sum && rightResult.sum >= crossResult.sum) {
        <span class="code-keyword">return</span> rightResult;
    } <span class="code-keyword">else</span> {
        <span class="code-keyword">return</span> crossResult;
    }
}

<span class="code-keyword">function</span> <span class="code-function">maxCrossingSubarray</span>(arr, low, mid, high) {
    <span class="code-comment">// Finde bestes Subarray links von der Mitte</span>
    <span class="code-keyword">let</span> leftSum = -Infinity;
    <span class="code-keyword">let</span> sum = <span class="code-number">0</span>;
    <span class="code-keyword">let</span> maxLeft = mid;

    <span class="code-keyword">for</span> (<span class="code-keyword">let</span> i = mid; i >= low; i--) {
        sum += arr[i];
        <span class="code-keyword">if</span> (sum > leftSum) {
            leftSum = sum;
            maxLeft = i;
        }
    }

    <span class="code-comment">// Finde bestes Subarray rechts von der Mitte</span>
    <span class="code-keyword">let</span> rightSum = -Infinity;
    sum = <span class="code-number">0</span>;
    <span class="code-keyword">let</span> maxRight = mid + <span class="code-number">1</span>;

    <span class="code-keyword">for</span> (<span class="code-keyword">let</span> j = mid + <span class="code-number">1</span>; j <= high; j++) {
        sum += arr[j];
        <span class="code-keyword">if</span> (sum > rightSum) {
            rightSum = sum;
            maxRight = j;
        }
    }

    <span class="code-comment">// Kombiniere beide Seiten</span>
    <span class="code-keyword">return</span> {
        sum: leftSum + rightSum,
        left: maxLeft,
        right: maxRight
    };
}

<span class="code-comment">// Zeitkomplexität: O(n log n)
// Raumkomplexität: O(log n) für Rekursionsstack</span>
            </div>

            <div class="info-box">
                <h3>Komplexitätsanalyse:</h3>
                <p style="margin: 10px 0;">Die Rekurrenzrelation lautet: <strong>T(n) = 2T(n/2) + O(n)</strong></p>
                <ul style="margin-left: 20px; line-height: 1.8;">
                    <li><strong>2T(n/2):</strong> Zwei rekursive Aufrufe auf Hälften der Größe n/2</li>
                    <li><strong>O(n):</strong> Linearer Aufwand für das Finden des crossing Subarrays</li>
                    <li><strong>Mit Master-Theorem:</strong> T(n) = O(n log n)</li>
                </ul>
            </div>
        </div>

        <div class="section">
            <h2>Algorithmen-Vergleich</h2>

            <div class="algorithm-comparison">
                <div class="algorithm-card">
                    <h3>Vollständige Enumeration</h3>
                    <p style="margin: 15px 0;">Durchprobieren aller möglichen Subarrays</p>
                    <div style="text-align: center; margin: 10px 0;">
                        <span class="complexity-badge complexity-medium">Zeit: O(n²)</span>
                        <span class="complexity-badge complexity-good">Raum: O(1)</span>
                    </div>
                    <p style="margin-top: 15px; font-size: 0.9em; color: #666;">
                        <strong>Vorteile:</strong> Einfach zu verstehen<br>
                        <strong>Nachteile:</strong> Langsam bei großen Arrays
                    </p>
                </div>

                <div class="algorithm-card" style="border-color: #667eea; border-width: 3px;">
                    <h3>Divide & Conquer</h3>
                    <p style="margin: 15px 0;">Rekursives Teilen und Zusammenführen</p>
                    <div style="text-align: center; margin: 10px 0;">
                        <span class="complexity-badge complexity-medium">Zeit: O(n log n)</span>
                        <span class="complexity-badge complexity-medium">Raum: O(log n)</span>
                    </div>
                    <p style="margin-top: 15px; font-size: 0.9em; color: #666;">
                        <strong>Vorteile:</strong> Parallelisierbar, elegante Struktur<br>
                        <strong>Nachteile:</strong> Mehr Speicher, komplexer
                    </p>
                </div>

                <div class="algorithm-card">
                    <h3>Kadane's Algorithmus</h3>
                    <p style="margin: 15px 0;">Dynamische Programmierung</p>
                    <div style="text-align: center; margin: 10px 0;">
                        <span class="complexity-badge complexity-good">Zeit: O(n)</span>
                        <span class="complexity-badge complexity-good">Raum: O(1)</span>
                    </div>
                    <p style="margin-top: 15px; font-size: 0.9em; color: #666;">
                        <strong>Vorteile:</strong> Optimal, sehr effizient<br>
                        <strong>Nachteile:</strong> Weniger intuitiv
                    </p>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>Weitere Anwendungen von Divide & Conquer</h2>

            <div class="info-box">
                <h3>Klassische Algorithmen:</h3>
                <ul style="margin-left: 20px; margin-top: 10px; line-height: 1.8;">
                    <li><strong>Merge Sort:</strong> Sortieren durch Teilen und Zusammenführen - O(n log n)</li>
                    <li><strong>Quick Sort:</strong> Sortieren mit Pivot-Element - O(n log n) im Durchschnitt</li>
                    <li><strong>Binäre Suche:</strong> Suchen in sortiertem Array - O(log n)</li>
                    <li><strong>Karatsuba-Multiplikation:</strong> Schnelle Multiplikation großer Zahlen</li>
                    <li><strong>Strassen-Algorithmus:</strong> Matrix-Multiplikation in O(n^2.807)</li>
                    <li><strong>Closest Pair Problem:</strong> Finden der zwei nächsten Punkte in der Ebene</li>
                    <li><strong>FFT (Fast Fourier Transform):</strong> Signalverarbeitung in O(n log n)</li>
                </ul>
            </div>

            <div class="info-box">
                <h3>Wann verwendet man Divide & Conquer?</h3>
                <ul style="margin-left: 20px; margin-top: 10px; line-height: 1.8;">
                    <li><strong>Teilproblem-Struktur:</strong> Problem lässt sich natürlich in Teilprobleme zerlegen</li>
                    <li><strong>Unabhängige Teilprobleme:</strong> Teilprobleme können unabhängig gelöst werden</li>
                    <li><strong>Effiziente Kombination:</strong> Teillösungen lassen sich effizient kombinieren</li>
                    <li><strong>Parallelisierung:</strong> Wenn parallele Verarbeitung möglich sein soll</li>
                    <li><strong>Optimale Asymptotik:</strong> Wenn bessere Zeitkomplexität als naive Ansätze benötigt wird</li>
                </ul>
            </div>

            <div class="info-box">
                <h3>Vorteile von Divide & Conquer:</h3>
                <ul style="margin-left: 20px; margin-top: 10px; line-height: 1.8;">
                    <li><strong>Bessere Komplexität:</strong> Oft O(n log n) statt O(n²)</li>
                    <li><strong>Parallelisierbar:</strong> Teilprobleme können parallel gelöst werden</li>
                    <li><strong>Cache-freundlich:</strong> Arbeitet mit kleineren Datenmengen</li>
                    <li><strong>Elegante Struktur:</strong> Klare, modulare Code-Struktur</li>
                    <li><strong>Mathematisch analysierbar:</strong> Mit Master-Theorem leicht zu analysieren</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        let isRunning = false;
        let currentArray = [];
        let recursionCallCount = 0;
        let maxDepth = 0;

        function displayArray(arr, highlights = {}) {
            const display = document.getElementById('arrayDisplay');
            display.innerHTML = '';

            arr.forEach((num, index) => {
                const element = document.createElement('div');
                element.className = 'array-element';

                if (num > 0) element.classList.add('positive');
                if (num < 0) element.classList.add('negative');

                if (highlights.left && index >= highlights.left.start && index <= highlights.left.end) {
                    element.classList.add('left-half');
                }
                if (highlights.right && index >= highlights.right.start && index <= highlights.right.end) {
                    element.classList.add('right-half');
                }
                if (highlights.crossing && index >= highlights.crossing.start && index <= highlights.crossing.end) {
                    element.classList.add('crossing');
                }
                if (highlights.best && index >= highlights.best.start && index <= highlights.best.end) {
                    element.classList.add('best');
                }

                element.textContent = num;
                element.id = `elem-${index}`;
                display.appendChild(element);
            });
        }

        async function startDivideConquer() {
            const input = document.getElementById('arrayInput').value;
            currentArray = input.split(',').map(x => parseInt(x.trim())).filter(x => !isNaN(x));

            if (currentArray.length === 0) {
                alert('Bitte gültiges Array eingeben!');
                return;
            }

            isRunning = true;
            recursionCallCount = 0;
            maxDepth = 0;

            document.getElementById('arrayLength').textContent = currentArray.length;
            document.getElementById('recursionDepth').textContent = 0;
            document.getElementById('recursiveCalls').textContent = 0;
            document.getElementById('maxSum').textContent = '-';
            document.getElementById('resultBox').style.display = 'none';
            document.getElementById('recursionTree').innerHTML = '<div style="text-align: center; color: #666;">Rekursionsbaum wird aufgebaut...</div>';

            displayArray(currentArray);

            const result = await maxSubarrayDivideConquerAnimated(currentArray, 0, currentArray.length - 1, 0);

            if (isRunning) {
                displayArray(currentArray, { best: { start: result.left, end: result.right } });

                document.getElementById('maxSum').textContent = result.sum;
                document.getElementById('resultBox').innerHTML = `
                    <strong style="color: #28a745; font-size: 1.3em;">
                        Maximales Subarray gefunden!
                    </strong><br><br>
                    Subarray: [${currentArray.slice(result.left, result.right + 1).join(', ')}]<br>
                    Summe: ${result.sum}<br>
                    Indices: [${result.left}...${result.right}]<br>
                    Rekursive Aufrufe: ${recursionCallCount}<br>
                    Maximale Tiefe: ${maxDepth}
                `;
                document.getElementById('resultBox').style.display = 'block';

                document.getElementById('stepInfo').innerHTML = `
                    <strong style="color: #28a745;">✓ Fertig!</strong>
                    Maximum Subarray mit Divide & Conquer gefunden
                `;
            }

            isRunning = false;
        }

        async function maxSubarrayDivideConquerAnimated(arr, low, high, depth) {
            if (!isRunning) return { sum: -Infinity, left: low, right: high };

            recursionCallCount++;
            maxDepth = Math.max(maxDepth, depth);

            document.getElementById('recursiveCalls').textContent = recursionCallCount;
            document.getElementById('recursionDepth').textContent = depth;

            document.getElementById('stepInfo').innerHTML = `
                Rekursionstiefe ${depth}: Betrachte Teilarray [${low}...${high}]<br>
                Werte: [${arr.slice(low, high + 1).join(', ')}]
            `;

            await sleep(800);

            // Basisfall
            if (low === high) {
                document.getElementById('stepInfo').innerHTML = `
                    Basisfall erreicht: Einzelnes Element arr[${low}] = ${arr[low]}
                `;
                await sleep(600);
                return {
                    sum: arr[low],
                    left: low,
                    right: high
                };
            }

            const mid = Math.floor((low + high) / 2);

            // Visualisiere Teilung
            document.getElementById('stepInfo').innerHTML = `
                <strong>TEILE:</strong> Teile bei Index ${mid}<br>
                Links: [${low}...${mid}], Rechts: [${mid + 1}...${high}]
            `;
            displayArray(currentArray, {
                left: { start: low, end: mid },
                right: { start: mid + 1, end: high }
            });
            await sleep(1000);

            // Rekursive Aufrufe
            document.getElementById('stepInfo').innerHTML = `
                <strong>BEHERRSCHE:</strong> Löse linke Hälfte [${low}...${mid}]
            `;
            displayArray(currentArray, { left: { start: low, end: mid } });
            const leftResult = await maxSubarrayDivideConquerAnimated(arr, low, mid, depth + 1);

            document.getElementById('stepInfo').innerHTML = `
                <strong>BEHERRSCHE:</strong> Löse rechte Hälfte [${mid + 1}...${high}]
            `;
            displayArray(currentArray, { right: { start: mid + 1, end: high } });
            const rightResult = await maxSubarrayDivideConquerAnimated(arr, mid + 1, high, depth + 1);

            document.getElementById('stepInfo').innerHTML = `
                <strong>BEHERRSCHE:</strong> Finde Crossing-Subarray über Mitte ${mid}
            `;
            const crossResult = await maxCrossingSubarrayAnimated(arr, low, mid, high);

            // Kombiniere
            document.getElementById('stepInfo').innerHTML = `
                <strong>KOMBINIERE:</strong><br>
                Links: Summe = ${leftResult.sum}, Rechts: Summe = ${rightResult.sum}, Crossing: Summe = ${crossResult.sum}
            `;
            await sleep(1000);

            let result;
            if (leftResult.sum >= rightResult.sum && leftResult.sum >= crossResult.sum) {
                result = leftResult;
                document.getElementById('stepInfo').innerHTML += `<br><strong>→ Wähle linkes Ergebnis</strong>`;
            } else if (rightResult.sum >= leftResult.sum && rightResult.sum >= crossResult.sum) {
                result = rightResult;
                document.getElementById('stepInfo').innerHTML += `<br><strong>→ Wähle rechtes Ergebnis</strong>`;
            } else {
                result = crossResult;
                document.getElementById('stepInfo').innerHTML += `<br><strong>→ Wähle crossing Ergebnis</strong>`;
            }

            displayArray(currentArray, { best: { start: result.left, end: result.right } });
            await sleep(800);

            return result;
        }

        async function maxCrossingSubarrayAnimated(arr, low, mid, high) {
            let leftSum = -Infinity;
            let sum = 0;
            let maxLeft = mid;

            for (let i = mid; i >= low; i--) {
                sum += arr[i];
                if (sum > leftSum) {
                    leftSum = sum;
                    maxLeft = i;
                }
            }

            let rightSum = -Infinity;
            sum = 0;
            let maxRight = mid + 1;

            for (let j = mid + 1; j <= high; j++) {
                sum += arr[j];
                if (sum > rightSum) {
                    rightSum = sum;
                    maxRight = j;
                }
            }

            const crossSum = leftSum + rightSum;

            displayArray(currentArray, { crossing: { start: maxLeft, end: maxRight } });
            await sleep(600);

            return {
                sum: crossSum,
                left: maxLeft,
                right: maxRight
            };
        }

        function stopAlgorithm() {
            isRunning = false;
            document.getElementById('stepInfo').innerHTML = '<strong style="color: #dc3545;">Gestoppt</strong>';
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Initialize
        window.addEventListener('load', () => {
            const input = document.getElementById('arrayInput').value;
            const arr = input.split(',').map(x => parseInt(x.trim()));
            displayArray(arr);
        });
    </script>
</body>
</html>
