<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breitensuche (BFS) Visualisierung</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: #333;
            text-decoration: none;
            font-weight: bold;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        .description {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            align-items: center;
        }

        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .btn-primary {
            background: #333;
            color: white;
        }

        .btn-primary:hover {
            background: #555;
        }

        .btn-secondary {
            background: #e0e0e0;
            color: #333;
        }

        .btn-secondary:hover {
            background: #d0d0d0;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .input-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        select {
            padding: 12px;
            font-size: 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: white;
            cursor: pointer;
        }

        .target-display {
            background: #fff3cd;
            border: 2px solid #ffc107;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 20px;
        }

        .target-display strong {
            display: block;
            margin-bottom: 5px;
            color: #856404;
        }

        .target-node {
            font-size: 1.5em;
            font-weight: bold;
            color: #856404;
        }

        .node.target circle {
            stroke: #ffc107;
            stroke-width: 5px;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            width: 200px;
        }

        .visualization {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 40px;
            min-height: 500px;
            position: relative;
        }

        svg {
            width: 100%;
            height: 500px;
        }

        .node {
            cursor: pointer;
        }

        .node circle {
            fill: #333;
            stroke: #fff;
            stroke-width: 3px;
            transition: all 0.3s;
        }

        .node.visiting circle {
            fill: #f5576c;
            stroke: #f093fb;
            stroke-width: 4px;
            r: 28;
        }

        .node.visited circle {
            fill: #764ba2;
            stroke: #667eea;
        }

        .node.completed circle {
            fill: #38ef7d;
            stroke: #11998e;
        }

        .node.queued circle {
            fill: #ffa726;
            stroke: #ff9800;
        }

        .node.found circle {
            fill: #4caf50;
            stroke: #ffc107;
            stroke-width: 6px;
            animation: foundPulse 1s ease-in-out infinite;
        }

        @keyframes foundPulse {
            0%, 100% {
                transform: scale(1);
                stroke-width: 6px;
            }
            50% {
                transform: scale(1.1);
                stroke-width: 8px;
            }
        }

        .node text {
            fill: white;
            font-size: 18px;
            font-weight: bold;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
        }

        .edge {
            stroke: #999;
            stroke-width: 2;
            fill: none;
        }

        .edge.traversed {
            stroke: #667eea;
            stroke-width: 3;
        }

        .edge.current {
            stroke: #f5576c;
            stroke-width: 4;
            animation: pulse 0.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 30px;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #333;
        }

        .stat-label {
            color: #666;
            margin-top: 5px;
        }

        .info-panel {
            background: #f8f9fa;
            color: #333;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            margin-bottom: 20px;
            min-height: 80px;
        }

        .info-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .info-content {
            font-size: 1.1em;
        }

        .queue-display {
            background: white;
            padding: 15px;
            border-radius: 5px;
            margin-top: 10px;
            border: 1px solid #e0e0e0;
            min-height: 50px;
        }

        .queue-item {
            display: inline-block;
            background: #333;
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            margin: 5px;
            font-weight: bold;
        }

        .level-label {
            font-size: 0.9em;
            color: #666;
            margin-top: 15px;
        }

        .level-info {
            display: inline-block;
            background: #e3f2fd;
            color: #1976d2;
            padding: 5px 12px;
            border-radius: 5px;
            margin: 5px 0;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Zurück zur Übersicht</a>

        <div class="header">
            <h1>Breitensuche (BFS) Visualisierung</h1>
        </div>

        <div class="description">
            <strong>Funktionsweise:</strong> Die Breitensuche (Breadth-First Search) ist ein Graph-Traversierungs-Algorithmus,
            der alle Knoten einer Ebene besucht, bevor er zur nächsten Ebene übergeht. Der Algorithmus verwendet
            eine Queue (Warteschlange), um die zu besuchenden Knoten zu verwalten. BFS eignet sich besonders für
            die Suche nach kürzesten Pfaden in ungewichteten Graphen und Level-Order Traversierung.
        </div>

        <div class="controls">
            <div class="input-container">
                <label>Zielknoten:</label>
                <select id="targetNode">
                    <option value="">Alle durchlaufen</option>
                    <option value="A">A</option>
                    <option value="B">B</option>
                    <option value="C">C</option>
                    <option value="D">D</option>
                    <option value="E">E</option>
                    <option value="F">F</option>
                    <option value="G">G</option>
                    <option value="H">H</option>
                </select>
            </div>
            <button class="btn-primary" onclick="startBFS()">BFS starten</button>
            <button class="btn-secondary" onclick="resetGraph()">Zurücksetzen</button>

            <div class="slider-container">
                <label>Geschwindigkeit:</label>
                <input type="range" id="speedSlider" min="200" max="2000" value="800" step="100">
                <span id="speedValue">800ms</span>
            </div>
        </div>

        <div class="target-display" id="targetDisplay" style="display: none;">
            <strong>Gesuchter Knoten:</strong>
            <div class="target-node" id="targetNodeDisplay">-</div>
        </div>

        <div class="info-panel">
            <div class="info-title">Aktueller Status</div>
            <div class="info-content" id="statusText">Warte auf Start...</div>
            <div class="level-label">
                Aktuelle Ebene: <span class="level-info" id="levelDisplay">-</span>
            </div>
            <div class="queue-display">
                <strong>Queue:</strong>
                <span id="queueDisplay">-</span>
            </div>
        </div>

        <div class="visualization">
            <svg id="graphSvg"></svg>
        </div>

        <div class="stats">
            <div class="stat-card">
                <div class="stat-value" id="visitedCount">0</div>
                <div class="stat-label">Besuchte Knoten</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="edgeCount">0</div>
                <div class="stat-label">Traversierte Kanten</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="time">0.0s</div>
                <div class="stat-label">Zeit</div>
            </div>
        </div>
    </div>

    <script>
        // Graph structure: adjacency list
        const graph = {
            'A': ['B', 'C'],
            'B': ['A', 'D', 'E'],
            'C': ['A', 'F', 'G'],
            'D': ['B'],
            'E': ['B', 'H'],
            'F': ['C'],
            'G': ['C', 'H'],
            'H': ['E', 'G']
        };

        // Node positions for visualization
        const nodePositions = {
            'A': { x: 400, y: 50 },
            'B': { x: 250, y: 150 },
            'C': { x: 550, y: 150 },
            'D': { x: 150, y: 250 },
            'E': { x: 350, y: 250 },
            'F': { x: 500, y: 250 },
            'G': { x: 650, y: 250 },
            'H': { x: 500, y: 380 }
        };

        let isRunning = false;
        let visitedCount = 0;
        let edgeCount = 0;
        let startTime = 0;
        let timerInterval = null;

        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');

        speedSlider.addEventListener('input', (e) => {
            speedValue.textContent = e.target.value + 'ms';
        });

        function initGraph() {
            const svg = document.getElementById('graphSvg');
            svg.innerHTML = '';

            // Draw edges first (so they appear behind nodes)
            const edges = new Set();
            for (const [node, neighbors] of Object.entries(graph)) {
                neighbors.forEach(neighbor => {
                    const edge = [node, neighbor].sort().join('-');
                    if (!edges.has(edge)) {
                        edges.add(edge);
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('class', 'edge');
                        line.setAttribute('id', `edge-${node}-${neighbor}`);
                        line.setAttribute('x1', nodePositions[node].x);
                        line.setAttribute('y1', nodePositions[node].y);
                        line.setAttribute('x2', nodePositions[neighbor].x);
                        line.setAttribute('y2', nodePositions[neighbor].y);
                        svg.appendChild(line);
                    }
                });
            }

            // Draw nodes
            for (const [node, pos] of Object.entries(nodePositions)) {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('class', 'node');
                g.setAttribute('id', `node-${node}`);

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', pos.x);
                circle.setAttribute('cy', pos.y);
                circle.setAttribute('r', 25);

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', pos.x);
                text.setAttribute('y', pos.y);
                text.textContent = node;

                g.appendChild(circle);
                g.appendChild(text);
                svg.appendChild(g);
            }
        }

        function updateStats() {
            document.getElementById('visitedCount').textContent = visitedCount;
            document.getElementById('edgeCount').textContent = edgeCount;
        }

        function startTimer() {
            startTime = Date.now();
            timerInterval = setInterval(() => {
                const elapsed = (Date.now() - startTime) / 1000;
                document.getElementById('time').textContent = elapsed.toFixed(1) + 's';
            }, 100);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        async function sleep(ms) {
            await new Promise(resolve => setTimeout(resolve, ms));
        }

        function updateStatus(text) {
            document.getElementById('statusText').textContent = text;
        }

        function updateQueue(queue) {
            const queueDisplay = document.getElementById('queueDisplay');
            if (queue.length === 0) {
                queueDisplay.innerHTML = '<span style="color: #999;">leer</span>';
            } else {
                queueDisplay.innerHTML = queue.map(node =>
                    `<span class="queue-item">${node}</span>`
                ).join('');
            }
        }

        function updateLevel(level) {
            document.getElementById('levelDisplay').textContent = level;
        }

        function highlightEdge(from, to) {
            const edge1 = document.getElementById(`edge-${from}-${to}`);
            const edge2 = document.getElementById(`edge-${to}-${from}`);
            const edge = edge1 || edge2;
            if (edge) {
                edge.classList.add('current');
            }
        }

        function markEdgeTraversed(from, to) {
            const edge1 = document.getElementById(`edge-${from}-${to}`);
            const edge2 = document.getElementById(`edge-${to}-${from}`);
            const edge = edge1 || edge2;
            if (edge) {
                edge.classList.remove('current');
                edge.classList.add('traversed');
                edgeCount++;
                updateStats();
            }
        }

        async function bfs(startNode, targetNode = null) {
            const visited = new Set();
            const queue = [startNode];
            const levels = new Map();
            levels.set(startNode, 0);
            let found = false;

            visited.add(startNode);
            let currentLevel = 0;
            updateLevel(currentLevel);

            while (queue.length > 0 && isRunning) {
                updateQueue(queue);
                await sleep(parseInt(speedSlider.value));

                const current = queue.shift();
                updateQueue(queue);

                // Update level if changed
                const nodeLevel = levels.get(current);
                if (nodeLevel !== currentLevel) {
                    currentLevel = nodeLevel;
                    updateLevel(currentLevel);
                    updateStatus(`Wechsel zur Ebene ${currentLevel}`);
                    await sleep(parseInt(speedSlider.value) / 2);
                }

                // Mark as visiting
                const node = document.getElementById(`node-${current}`);
                node.classList.remove('queued');
                node.classList.add('visiting');

                if (targetNode) {
                    updateStatus(`Besuche Knoten ${current} (Ebene ${nodeLevel}) - Suche nach ${targetNode}...`);
                } else {
                    updateStatus(`Besuche Knoten ${current} (Ebene ${nodeLevel})`);
                }
                await sleep(parseInt(speedSlider.value));

                // Check if target found
                if (targetNode && current === targetNode) {
                    node.classList.remove('visiting');
                    node.classList.add('found');
                    updateStatus(`Zielknoten ${targetNode} in Ebene ${nodeLevel} gefunden!`);
                    found = true;
                    break;
                }

                // Mark as visited
                visitedCount++;
                updateStats();
                node.classList.remove('visiting');
                node.classList.add('visited');

                updateStatus(`Knoten ${current} besucht - Überprüfe Nachbarn`);
                await sleep(parseInt(speedSlider.value) / 2);

                // Add neighbors to queue
                for (const neighbor of graph[current]) {
                    if (!visited.has(neighbor)) {
                        highlightEdge(current, neighbor);
                        updateStatus(`Füge Nachbar ${neighbor} zur Queue hinzu`);
                        await sleep(parseInt(speedSlider.value) / 2);

                        visited.add(neighbor);
                        queue.push(neighbor);
                        levels.set(neighbor, nodeLevel + 1);

                        const neighborNode = document.getElementById(`node-${neighbor}`);
                        neighborNode.classList.add('queued');

                        markEdgeTraversed(current, neighbor);
                        updateQueue(queue);
                    } else {
                        const edge1 = document.getElementById(`edge-${current}-${neighbor}`);
                        const edge2 = document.getElementById(`edge-${neighbor}-${current}`);
                        const edge = edge1 || edge2;
                        if (edge) edge.classList.remove('current');
                    }
                }

                node.classList.remove('visited');
                node.classList.add('completed');
            }

            updateQueue([]);
            if (!found && targetNode) {
                updateStatus(`Breitensuche abgeschlossen - ${targetNode} wurde nicht gefunden!`);
            } else if (found) {
                updateStatus(`Breitensuche abgeschlossen - ${targetNode} in ${levels.get(targetNode)} Schritten gefunden!`);
            } else {
                updateStatus('Breitensuche abgeschlossen!');
            }

            return found;
        }

        async function startBFS() {
            if (isRunning) return;

            const targetNodeSelect = document.getElementById('targetNode');
            const target = targetNodeSelect.value || null;

            visitedCount = 0;
            edgeCount = 0;
            updateStats();

            // Clear the graph visually
            initGraph();

            // Show target if selected
            if (target) {
                document.getElementById('targetDisplay').style.display = 'block';
                document.getElementById('targetNodeDisplay').textContent = target;
                const targetNode = document.getElementById(`node-${target}`);
                if (targetNode) targetNode.classList.add('target');
            } else {
                document.getElementById('targetDisplay').style.display = 'none';
            }

            isRunning = true;
            startTimer();

            await bfs('A', target);

            isRunning = false;
            stopTimer();
        }

        function resetGraph() {
            isRunning = false;
            stopTimer();
            visitedCount = 0;
            edgeCount = 0;
            document.getElementById('time').textContent = '0.0s';
            updateStats();
            updateStatus('Warte auf Start...');
            updateQueue([]);
            updateLevel('-');
            document.getElementById('targetDisplay').style.display = 'none';
            initGraph();
        }

        // Initialize on load
        initGraph();
    </script>
</body>
</html>
